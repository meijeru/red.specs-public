= Red Language Specification - draft
:imagesdir: /images
:toc:
:toclevels: 3
:numbered:

== Introduction

=== Purpose

The purpose of this document is to systematically describe the lexical/syntactic
and semantic rules of the Red programming language, and thus to be
the authoritative document for: 

* verifying implementation conformity
* tracking changes in the language design, including why changes were made
* acting as a reference for tests

In as much as feasible, and in order to avoid duplication, existing pieces
of official documentation will be referred to. A list of those can be found in
section 17.

Because of the wealth of built-in functions that Red makes available, combined
with the numerous optional facilities ("refinements") that these functions have,
it is not possible to give an exhaustive treatment of Red's functionality.
Red allows quite detailed information about a function's operation to be
documented within the function specification, and this should be consulted
in order to be able to use any function optimally. See section 13.6.

This document is *not* intended to be used in order to learn the language (tutorial);
for that purpose sufficient materials can be found elsewhere.
_** need one comprehensive and sufficiently maintained collection of links **_

=== Conventions

In this document, technical terms -- whether in general use or specific to the Red
language -- will be written in _italics_ when first used and sometimes also on
some subsequent occasions. Values from the Red language, grammatical categories,
rule numbers and Unicode Code Point numbers will be written in `monospace font`.

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter.
The prefix letter can be:

* **`S`**: for lexical and syntactic rules.
* **`E`**: for evaluation rules.

== Overview

=== Characterization

Red is a next-generation programming language strongly inspired by Rebol,
but with a broader field of usage thanks to its native-code compiler,
from system programming to high-level scripting and cross-platform reactive GUI,
while providing modern support for concurrency. Red has its own complete cross-platform
toolchain, featuring two compilers, an interpreter and a linker,
not depending on any third-party library. Once complete, Red will be self-hosted.

_**The concurrency part is far from being implemented, mention it here?**_

=== Red toolchain

A program written in Red is intended to be executed on a _target computer_.
To that end, it will be submitted to the _Red toolchain_ which is a program
executing on a _host computer_; this computer may be, but need not be
identical to the target computer. In case the two are identical,
the program execution may take the form of _interpretation_, i.e. the effect
of the program is the result of the toolchain's operation itself.
In either case, the execution may occur through _compilation_, i.e. the toolchain
produces a program in a lower-level language (e.g. machine code) suitable
for execution on the target computer. The toolchain is to be constructed
such that the effect of the program is the same whether it is executed through
interpretation or compilation. A further facility of the toolchain is
that it provides one or more _interactive consoles_, i.e. visual interfaces
which accept program fragments and display the result of evaluating them
(REPL or Read Evaluate Print Loop).

Information about the installation and usage of the toolchain can be found
in the README file of the https://github.com/red/red[Red repository on Github].
This repository contains the full source code of the toolchain, which may be
said to be the final authority on what the Red language is.

=== Values and types

An important property of Red is that any Red program is a _sequence
of Red values_, i.e. code and data are a priori indistinguishable.
In other words, Red is _homoiconic_. Thus, execution of a Red program
is tantamount to evaluating each of its constituent values in turn,
according to the evaluation rules. Each Red _value_ has a _type_ and the types
themselves are also values of the language. The type of each value can be
determined either _lexically_ (_single values_), or _syntactically_ (_grouped
values_).

=== Words, contexts and binding

A special category of values is formed by _words_, that play
a similar role to identifiers and keywords of other languages.
Red does *not* have identifiers nor keywords: as will be explained in more
detail below, any _word_ may _refer_ to another value in some _context_.
The word is said to be _bound to_, or _in_ the context.
Evaluation of a word yields the value it refers to. The evaluation rules
given below will state, amongst others, how words can come to refer
to values in the course of program execution.

A large number of words are _pre-defined_ to refer to certain values
in the _global context_, notably to _built-in functions_, _types_
(type names conventionally end in `!`) and _constants_ such as
the truth values: `true` and `false`, as well as `none` ("nil"
or "null" in other languages). See section 14 for the complete list.

=== Dialects

Red makes available a large number of different value types. The evaluation
rules stated below describe the interpretation of these values when they
occur in a Red _program_ which, as stated before, is nothing more or less
than a sequence of values.
The users may furthermore use and interpret Red values, when considered as _data_,
in ways of their own, and thus create _dialects_ or _Domain Specific Languages
(DSLs)_.

In fact, Red itself contains a number of dialects where blocks of data are
interpreted in a specific way; this includes the _preprocessor dialect_, 
the _parse dialect_, the _visual interface dialect (VID)_, which also uses
the _draw dialect_ and the _shape dialect_, the various _spec dialects_
involved in defining vectors, images, bitsets, objects, errors, maps,
functions and routines, furthermore the _compose dialect_
and the _system dialect_ (Red/System).

Red/System is on the one hand a language of its own: it is a C-level language
with memory pointer support and a very basic and limited set of datatypes.
Programs written in Red/System can be compiled and executed using the toolchain.
As a dialect of Red its purpose is to provide low-level system programming
capabilities, and it serves both as a tool to build Red's runtime library
and as intermediate language for the compiler to generate machine code from.
Red/System is specified in a separate document (see section 17).

== Structure of Red programs

=== Textual structure

For submission to the Red toolchain, a Red program must be prepared as a text file.
This may contain any _Unicode Code Points_, encoded using the _UTF-8 scheme_. 

As a first operation of the toolchain, the text file will be subjected to _lexical analysis_
which will break the text up in a series of _lexemes_, i.e. textual representations of Red
_single values_, interspersed with _grouping tokens_. The grouping tokens should occur in
properly nested pairs, and are the following: `( ), [ ], #( ), #[ ]`. A sequence of lexemes
enclosed in matching grouping tokens represents a Red _grouped value_ of a certain type,
and this construct may again be enclosed in grouping tokens etc. 

As a rule, lexemes must be separated from each other and from grouping tokens by
one or more _whitespace characters_. In the Red source text, whitespace characters are
space (`U+0020`), tab (`U+0009`), line feed (`U+000A`), next line (`U+0085`)
and non-breaking space (`U+00A0`). Consequently, Red program texts are _free form_,
i.e. neither their arrangement in separate lines, nor their formatting with indentation
and the like, has any significance for their interpretation.

_**This is most certainly short of some whitespace values, please correct See also issue #2492**_

In certain cases, where there can be no ambiguity, the requirement for whitespace between values
can be relaxed. For example, it is possible to omit whitespace between two consecutive `block!`
values and between `word!` values and `block!` values. These examples are all syntactically valid:
....
     either x = 1["OK"]["NOK"]
     either x = 1  ["OK"]     ["NOK"]
     either x = 1 [
         "OK"
     ] [
         "NOK"
     ]
....

_Comments_, which have no significance for the operation of the program, may be placed following
a semicolon `;` until the end of an input line (_end-of-line comment_), or they may follow the word
`comment` and be formulated as a single Red value -- most usefully a series of characters enclosed
in `{ }` or a series of Red values enclosed in `[ ]`.

A well-formed Red program begins with a _prologue_ which may contain _metadata_ for the toolchain
and/or the reader. The relevant data will be described in section 16.

=== Formal grammar

A formal grammar corresponding to the above presentation is given below. This
omits the separation by whitespace, and the presence of end-of-line comments.
As usual, `*` means zero or more instances of the non-terminal.
The comment to any production rule, which starts after the `;` on the line,
states the type of the single or grouped values generated by this rule.
The significance of the types is found in section 4.1.
Any non-terminal that is not further defined in this grammar is explained
in the individual sub-sections of section 5.

**`S100`**:: program structure
....
<program>  ::= <prologue> <value>*
<prologue> ::= Red [ <value>* ]
<value>    ::= <lexeme> | <group>
<lexeme>   ::= <integer-literal>                        ; integer!
             | <float-literal>                          ; float!
             | <integer-literal>% | <float-literal>%    ; percent!
             | <integer-literal>x<integer-literal>      ; pair!
             | <time-literal>                           ; time!
             | <tuple-literal>                          ; tuple!
             | <word-literal>                           ; word!
             | '<word-literal>                          ; lit-word!
             | <word-literal>:                          ; set-word!
             | :<word-literal>                          ; get-word!
             | /<word-literal>                          ; refinement!
             | #<word-literal>                          ; issue!
             | <char-literal>                           ; char!
             | <string-literal>                         ; string!
             | <file-literal>                           ; file!
             | <url-literal>                            ; url!
             | <email-literal>                          ; email!
             | <tag-literal>                            ; tag!
             | <binary-literal>                         ; binary!
             | <path-literal>                           ; path!
             | '<path-literal>                          ; lit-path!
             | <path-literal>:                          ; set-path!
             | :<path-literal>                          ; get-path!
    <group>    ::= <paren-literal>
             | <block-literal>
             | <map-literal>
             | <constructor>
    <paren-literal> ::= ( <value>* )                    ; paren!
    <block-literal> ::= [ <value>* ]                    ; block!
    <map-literal> ::=   #( <value>* )                   ; map! (even number of values only)
    <constructor> ::=   #[ <value>* ]                   ; reserved for general typed value constructor
....

=== Expressions and evaluation order

At a semantic level, the constituents of a Red program are not values but _expressions_.
An expression groups one or more values, and may be formed in three ways: as an _application_
of a (prefix) _function_, as an _infix expression_ which uses an _operator_,
or as a _binding_ of a word to refer to a value.

The statement made earlier: "execution of a Red program is tantamount to evaluating
each of its constituent _values_ in turn, according to the evaluation rules" can therefore
be refined to: "execution of a Red program is tantamount to evaluating each of its
constituent _expressions_ in turn, according to the evaluation rules", with _expression_
being construed as the largest sequence of values conforming to the following definition:

**`S101`**:: expressions
....
<expression>      ::= <operand>
                    | <expression> <op> <operand>
<operand>         ::= <value>
                    | <prefix-function> <argument>*
                    | <word-literal>: <expression>
<argument>        ::= <expression>
....

Here `<op>` is an expression which evaluates to an operator, i.e. an `op!` value representing
an infix function of two arguments, and `<prefix-function>` is an expression which evaluates
to a prefix function (value of type `action! native! function!` or `routine!`). The
number of expressions following a prefix function is strictly dependent on the function value
and is known as the _arity_ of the function value. See further the evaluation rules given
in section 7. Evaluation of the operands of operators has _precedence_
over function application and binding; also, as suggested in rule `S101`, operators are strictly _left associative_,
there is no precedence between any two operators. The arguments of a function simply follow
the function itself, they are not enclosed in parentheses, thus for the reader to understand a program,
knowledge of the arity of functions is necessary. Evaluation order can of course be influenced
by the use of parentheses.

Some basic examples:
....
1 + 2 3 + 4                ; 6 values, 2 expressions 
1 + 2 * 3                  ; result is 9, not 7
1 + (2 * 3)                ; result is 7
pick copy "abc" 1          ; 1 is argument to pick, since copy has 1 argument itself
copy/part "abc" 2          ; with the "refinement" /part, copy now has 2 arguments
mod x 2 + 1                ; mod has 2 arguments; this will be interpreted as mod x 3
1 + mod x 2                ; this is what was probably meant
(mod x 2) + 1              ; another way  of writing that
1 + a: 2                   ; result is 3, a now refers to 2
....

In what follows, terms like `<integer-literal>` will be used to refer to lexemes;
to indicate the corresponding values, terms like "value of type `integer!`,
`integer!` value" or plain "integer" will be used. Also, in grammar fragments,
on the right-hand side of the `::=` sign, terms like `<integer>` will stand for
" `<expression>` evaluating to an `integer!` value" etc., while
decorated non-terminals like `<true-block>` will stand for `<block>` etc.

== Types

=== Type list
 
The full list of types of the languages is given below, with an explanation of the usage of their values.

....
type            usage of values

datatype!       types of the language (first class values)
typeset!        sets of types
none!           single value: none, i.e. a value belonging to none of the other types
logic!          true or false
char!           character (Unicode Code Point)
integer!        integer numbers 
float!          floating point (decimal) numbers
percent!        id. expressed as a percentage
time!           time interval or point in time, stored as a floating point number of seconds
pair!           2-dimensional coordinates or size 
tuple!          e.g. color in RGB or other scheme, IPv4 adres
word!           identifier that can be bound
lit-word!       quoted (unevaluated) word
set-word!       word to be given a value to refer to
get-word!       word to be evaluated
refinement!     optional argument of function
issue!          literal identifier (word that does not refer to a value)
handle!         opaque integer for communication with operating system
block!          ordered collection of values of any type (polymorphic array),
                may also be used as unordered collection (set)
hash!           block with quick access
paren!          differs from block in behaviour under evaluation  
path!           specifying optional arguments in function calls,
                selection of components of composite values
lit-path!       quoted (unevaluated) path
set-path!       for setting a component of a composite value
get-path!       path to be evaluated
vector!         ordered sequences of values of identical type, which can be
                char! or integer! (8/16/32 bits), percent! or float! (32/64 bits);
                default: 32 bits for char! or integer! and 64 bits otherwise
string!         sequence of characters (Unicode Code Points)
file!           file or directory (folder)
url!            URL
tag!            tag in the sense of HTML, XML etc.
email!          email address
binary!         sequence of bytes
image!          2-dimensional array of pixels (RGBA values stored in 4 bytes each) 
bitset!         sequence of values true or false, used e.g. to model sets of
                non-negative integers, such as Unicode Code Points
map!            collection of pairs of values where the first value in each pair functions
                as key for retrieval of the second; keys are restricted to types in
                scalar!, any-word! and any-string!
object!         collection of word-value pairs with a context in which the words
                (also called fields) are bound, and are referring to the corresponding values;
                objects are capable of triggering asynchronous events in response
                to changes in their components, thus enabling reactive programming;
                objects have a "class" property associated with them
error!          specialized objects representing error conditions
native!         pre-defined functions with built-in evaluation according to special rules
action!         pre-defined polymorphic functions of one or two arguments with built-in evaluation
op!             operators, i.e. infix functions of two arguments, each one is
                derived from a native! action! function! or routine! value
function!       user-defined functions; as with native! and action! values,
                function! values may have optional arguments, indicated by refinements
routine!        user-defined functions with body in Red/System code
unset!          single value indicating the absence of a usable value
event!          representation of external activity   

TBD
date!
point!
closure!
port!
ref!
struct!
library!
....

=== Type categories

As seen in the previous section, Red has a rather large number of different types.
For a better understanding of their nature and that
of their values, it is useful to make a number of distinctions into different categories.

* textual representation: types having lexically/syntactically representable values or not
* internal storage: _direct types_ vs _indirect types_ and _function types_
* internal structure of values: _atomic types_ vs _composite types_
* reflectivity: types with values that admit _reflection_  or not
* evaluation: _passive types_, _decaying types_, _active types_, _function types_
* implementation of built-in functions: _parent types_

==== Types according to their textual representation

Not all types listed have lexically or syntactically determined values. Those that have not
may have their values generally be represented in programs by
expressions of the form `make <type> <spec>`, where `<type>` is an expression that evaluates
to a type name or to a value of the desired type, and `<spec>` is an `<expression>`
whose value is interpreted by the `make` function as appropriate for the given type.
This is explained in detail in section 5.3.
_**An alternative, syntactical representation,
will be offered for a number of types (or all??) in the form of construction syntax
`#[<type> <spec>]`**_.

==== Direct/Indirect/Function types

Red values are internally stored using _value slots_ of uniform size. Values of _direct types_
fit completely into one such slot; for values of _indirect types_, which have a variable number
of _components_, the slot stores a _pointer_ to a further storage area that holds the components
of the value. As a consequence, when a word is made to refer to a value of indirect
type or such a value is supplied as actual argument to a function, the components of this value may
be changed through operations on the word or the function formal argument.
In order to prevent this, values of indirect types must be explicitly copied before being
transmitted as argument or having a word refer to them. The built-in function `copy` will do this.
If the components themselves are of indirect type, `copy` will not copy their components,
unless the function refinement `/deep` is used. 

A third category to be distinguished is that of _function types_, where pointers to the argument
list and the body are stored in the slot.

==== Atomic/Composite types

Values of certain types have _components_ which may be extracted and/or changed using a variety of
facilities which will be specified below under evaluation. Such types are called _composite_ 
and the others are _atomic_. All indirect types are composite, but the converse
is not true: some direct types are also composite. However, component selection
in values of direct types cannot be used to change the component, only to extract it.
Making such a component refer to a new value results in a new instance of the direct value
being created, having the changed component.

==== Types that admit reflection

Values of some types have (internal) properties of interest to the user which may usefully be exposed.
E.g. the set of words from the word/value pairs making up an object may be retrieved by the built-in
function `words-of`. Likewise, the argument spec of a function may be retrieved by `spec-of`.

_** We should perhaps consider `context?` or rather `context-of` as a reflector also**_

==== Types according to the evaluation of their values

* Values of _passive types_ evaluate to themselves. The great majority of types belong to this category.
* Values of _decaying types_ are quoted instances of other values. They evaluate to the unquoted value.
* Values of _active types_ are bound to a context, their binding can be retrieved to yield the value referred to.
* Values of _function types_, when evaluated, result in the application of the function to its arguments.

Detailed rules for the evaluation in these various cases are given in section 7. 

==== Parent types

The notion of _parent type_ arises in the implementation of _actions_, i.e. pre-defined polymorphic
functions of up to two arguments with built-in evaluation, e.g. `add`, `subtract`, `copy`, `find`, etc.
The implementation uses a _dispatch table_ which contains a pointer to a specific run-time
function for each allowed combination of action and type of first argument. These functions
are grouped by the type to which they apply. Now for any action/type combination,
such function may be designated as _inherited_ from the parent type, and in this way
two or more types may share the same implementation for that action.

_**Mention pseudo types `symbol`, `series!` and `context!`?**_ 

==== Overview table

....
type     value representation  direct (D)/      atomic (A)/   reflection     passive (P/        parent type
            lexical (L)/       indirect (I)/    composite (C)    (R)         decaying (D)/
            syntactic (S)/     function (F)     values                       active (A)/
            using make (M)/      storage                                     function (F)
            using words (W)                                                  evaluation
                                                                   
datatype!         W                 D                A                            P   
typeset!          M                 D                A                            P   
none!             W                 D                A                            P
logic!            W                 D                A                            P
char!             L                 D                A                            P               integer!
integer!          L                 D                A                            P
float!            L                 D                A                            P
percent!          L                 D                A                            P               float!
time!             L                 D                C                            P               float!
pair!             L                 D                C                            P
tuple!            L                 D                C                            P
word!             L                 D                A             R              A              (symbol!)
lit-word!         L                 D                A             R (#2618)      D               word!
set-word!         L                 D                A             R (#2618)      A               word!
get-word!         L                 D                A             R (#2618)      A               word!
refinement!       L                 D                A             R (#2618)      P               word!
issue!            L                 D                A             R (#2618)      P               word!
handle!           W                 D                A                            P               integer!
block!            S                 I                C                            P              (series!)
hash!             M                 I                C                            P               block!
paren!            S                 I                C                            A               block!
path!             L                 I                C                           A+F              block!
lit-path!         L                 I                C                            D               path!
set-path!         L                 I                C                            A               path!
get-path!         L                 I                C                            A               path!
vector!           M                 I                C                            P               string!
string!           L                 I                C                            P              (series!)
file!             L                 I                C                            P               url!
url!              L                 I                C                            P               string!
tag!              L                 I                C                            P               string!
email!            L                 I                C                            P               string!
binary!           L                 I                C                            P               string!
image!            M                 I                C                            P
bitset!           M                 I                C                            P
map!             S+M                I                C             R              P
object!           M                 I                C             R              P
error!            M                 I                C             R              P               object!
native!           W                 F                A             R              F
action!           W                 F                A             R              F               native!
op!              W+M                F                A             R              F               native!
function!         M                 F                A             R              F              (context!)
routine!          M                 F                A             R              F               function!
unset!            M                 D                A                            P
event!            W                 D                C                            P

TBD
date!
point!
closure!
port!
ref!
struct!
library!
....

=== Type hierarchy

For the convenience of the user, certain typesets have been pre-defined
which group related types. These will notably be used for indicating
the allowed types of arguments to _polymorphic functions_. E.g. `power` takes
two arguments whose types are both in the typeset `number!`.

....
any-type!              
|--internal!            
|  |--unset!
|--default!              
   |--external!
   |  |--event!
   |--immediate!         
   |  |--datatype!        
   |  |--typeset!         
   |  |--none!            
   |  |--logic!           
   |  |--scalar!          
   |  |  |--char!          
   |  |  |--number!        
   |  |  |  |--integer!     
   |  |  |  |--any-float!   <---- see issue #2565
   |  |  |     |--float!     
   |  |  |     |--percent!   
   |  |  |--time!          
   |  |  |--pair!          
   |  |  |--tuple!         
   |  |--any-word!
   |  |  |--word!          
   |  |  |--lit-word!      
   |  |  |--set-word!      
   |  |  |--get-word!      
   |  |--refinement!    
   |  |--issue!         
   |  |--handle!            
   |--series!            
   |  |--any-block!       
   |  |  |--any-list!      
   |  |  |  |--block!       
   |  |  |  |--hash!        
   |  |  |  |--paren!       
   |  |  |--any-path!      
   |  |     |--path!        
   |  |     |--lit-path!    
   |  |     |--set-path!    
   |  |     |--get-path!    
   |  |--vector!          
   |  |--any-string!      
   |  |  |--string!        
   |  |  |--file!          
   |  |  |--url!           
   |  |  |--tag!           
   |  |  |--email!         
   |  |--binary!          
   |  |--image!           
   |--bitset!            
   |--map!               
   |--any-object!        
   |  |--object!          
   |  |--error!           
   |--any-function!      
      |--native!          
      |--action!          
      |--op!              
      |--function!        
      |--routine!         
   
TBD
date!
point!
closure!
port!
ref!
struct!
library!
....

=== Type and typeset related functions

The built-in function `type?` will yield the type of a value. It has a refinement
`/word` which will yield the type as a `word!` value. For every pre-defined
type and typeset there is a built-in function which will test if a value is of that type
(or a type in that typeset). These functions have the name of the type(set) with the
`!` replaced by `?`.

Examples:
....
type? 1        -> integer!
integer? 1     -> true
number? 1.0    -> true
....

== Values

=== Introduction

The types whose names are mentioned in rule `S100` (`integer!` to `map!`) are the only ones
that have lexically or syntactically determined values. Values that are not lexically
or syntactically determined may generally be represented in programs with the help
of the built-in function `make`. This is one of three related means that Red provides
in order to produce new values:

* creating them with the help of other ones (built-in function `make`)
* converting values to related ones of other types (built-in function `to`)
* changing their type without changing their content (built-in function `as`)

All three built-in functions have two arguments: `<target>` and `<spec>`,
where `<target>` evaluates to a type (`datatype!` value) or to a value (_prototype_)
of the desired type and `<spec>` is interpreted as appropriate for the given type. 

For several types, the available values are referred to by words at program start: `none!` has `none`,
`logic!` has `true = yes = on` and `false = no = off`, and `datatype!` has all the valid
type names pre-defined (no further datatypes can be defined by the user);
likewise `native! action!` and `op!` have all the built-in functions
and operators pre-defined (values of type `action!` and `native!` cannot
be made by the user, but new infix operators can be).
Values of types `event!` and `handle!`, that are used to communicate with
the operating system, can only be represented by words that are arguments
to functions handling this communication.

_**Mention general typed value constructor #[ <type> <value>* ]**_

The following sub-sections will specify the lexical structure resp. the `<spec>` argument
of the `make`, `to` and `as` function for values of each of the types as appropriate.
For convenience, the `<target>` argument is specified in evaluated form when it is a `<type>`,
and the `<spec>` argument is presented as a `<block-literal>` when it is important to
show the components of the block. It should be remembered, however, that `make to` and `as` do
evaluate their arguments, so that any `<expression>`  which evaluates to a type or a block
is allowed in the relevant argument positions.

=== Lexical structure of values

==== `integer!`

**`S111`**::
An `<integer-literal>` is written as a signed integer number from `-2^31^` to `2^31^-1`
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
_**Hexadecimal notation, eg FFh, is omitted as this is under discussion**_

Examples: `123`  `-123`  `+0001`  `1'000`

==== `float!`

**`S112`**::
A `<float-literal>` is written as a signed floating point number in the range of the
_IEEE 754 binary64 format_, in decimal notation. Leading zeroes are allowed,
as well as `'` signs for separation.
No zero is needed before the decimal point when the absolute value is smaller than `1.0`.
The number may be followed by `E` or `e` with a signed integer exponent on base 10.
Note that in this case, no decimal point is required.

Examples: `1.23`  `-0.5`  `.5`  `+010.20`  `1E9`

==== `time!`

**`S113`**::
....
<time-literal> ::= <hmsd> | +<hmsd> | -<hmsd>
<hmsd> ::= <hours>:<minutes> | <hours>:<minutes>:<seconds> | <hours>:<minutes>:<seconds>.<decimals> |
           <minutes>:<seconds>.<decimals>
....

where `<hours> <minutes> <seconds>` and `<decimals>` may each be any unsigned `<integer-literal>`
(leading zeroes are allowed, carry is performed as appropriate when the numbers are outside
the normal range `0..23` for hours, `0..59` for minutes and seconds).

Examples: `10:20`  `10:20:30.456`  `20:30.5`  `-1:00:00`

==== `tuple!`

**`S114`**::
A `<tuple-literal>` is written as 3 to 12 `integer!` values in the range `0..255` separated by dots `.`

Examples: `192.168.1.2` (an IPv4 address), `255.255.128` (an RGB value)

==== `word!`

**`S115`**::
A `<word-literal>` is written as one or more characters from the entire Unicode range excluding _control characters_
(notably Unicode sets C0, C1), whitespace characters and the following set: `/ \ ^ , [ ] ( ) { } " # $ % @ : ;`.
A `<word-literal>` does not begin with `0-9` or `'`.
Words are _case-insensitive_, i.e. changing any letter in the word into the corresponding upper- or lower-case
variant does not create a different word.

Examples: `abc`  `Abc`  `ABC`  `+`  `<>`  `integer!`  `last-item?` ; the first three are the same `word!` value.

Note: punctuation characters from the ASCII subset that *are* allowed in words are: `! & ' * + - . < = > ? _ `` `| ~`.

==== `char!`

**`S116`**::
....
<char-literal> :: = #"<single-character>"
<single-character> ::= <viewable-character> | <escaped-character> | <hexadecimal-codepoint>
<escaped-character> :: =  ^(null) | ^@ | ^(back) | ^(tab) | ^- | ^(line) | ^/ | ^(page) | ^(esc) | 
              ^" | ^^ |  ^(del) | ^~ | ^A | ^B | ... | ^Z | ^[ | ^\ | ^] | ^_
<hexadecimal-codepoint> :: = ^(<hex>) | ^(<hex><hex>) | ^(<hex><hex><hex>) | ^(<hex><hex><hex><hex>)  
....
where `<hex>` is two hexadecimal digits `0-9 A-F a-f`, thus `00` - `FF`

A `<char-literal>` must be a valid single Unicode code point, i.e. an integer in the range `0` to `10FFFFF` (hexadecimal notation). 

A `<viewable character>` is, in most cases, simply a displayable character. For example, `e`, `Ã©`, `â‚¬` or `ðŸ˜€`.
When a displayable character requires two or more graphemes to display it, each grapheme requires a separate Red character.
For example, when `Ã©` is encoded in its two character decomposed form `e` (`U+0065`) followed by
the combining `Â´` (`U+0301`) they cannot be considered a single `char!` value, and programs must
explicitly handle their interpretation. 

The correspondence between the escaped characters and Unicode Code Points is given in the table below.

     Named Form   Short Form    Character           Code Point
     
     #"^(null)    #"^@"         null                U+0000
     #"^(back)"   #"^H"         backspace           U+0008
     #"^(tab)"    #"^I" #"^-"   horizontal tab      U+0009
     #"^(line)"   #"^J" #"^/"   line feed           U+000A
     #"^(page)"   #"^L"         form feed           U+000C 
     #"^(esc)"    #"^["         escape              U+001B
     #"^(del)"    #"^~"         delete              U+007F
     
     
     #"^""                      " - double quote    U+0022
     #"^^"                      ^ - caret           U+005E
     #"^A" - #"^Z"              control characters  U+0001 - U+001A
     #"^[" #"^\" #"^]"          control characters  U+001B - U+001D
     #"^_"                      control character   U+001F
    
Note that code point `U+001E` cannot be represented by `#"^^"` as expected, since that is already taken for caret.
Note also that `^` will be ignored in front of any single character with which it does not form (the beginning of)
an `<escaped-character>` or `<hexadecimal-codepoint>`. Thus e.g. `^3` yields the same as `3`.

Examples: `#"A"  #"^/"  #"^(0A)"`

==== `string!`

**`S117`**::
....
<string-literal> ::= "<single-character>*" | {<single-character>*}
....

where `<single-character>` is defined in rule `S116`

When the `<string-literal>` is delimited by `" "` it must not contain unescaped _new-line characters_
`U+000A`, `U+0085`, `U+2028` and `U+2029`. When the `<string-literal>` is delimited by `{ }` it may contain
unescaped new-line characters and any `"` as well as nested `{ }` pairs, but any unpaired `{` or `}`
character that is part of the `<string-literal>` must be escaped by preceding it with `^`.
Within a `<string-literal>`, the same remark holds for `^` as noted above for a `<char-literal>`. 

Examples:
....
"abc^/def"
{abc +
def}
....

==== `file!`

**`S118`**::

A `<file-literal>` is written as `%` followed by one or more non whitespace characters, or by zero or more
characters enclosed in `"  "` in which case whitespace characters except line feed and next line may be
included. The interpretation of this value is operating system dependent, but escaped characters of the
form `%<hex>` are accepted and converted.

==== `url!`

**`S119`**::

A `<url-literal` is written as three or more non whitespace characters, of which at least one `:` which must not
be the first or last character. Escaped characters of the form `%<hex>` are accepted and converted.

==== `email!`

**`S120`**::

An `<email-literal>` is written as two or more characters containing one `@` but not beginning with it.
Escaped characters of the form `%<hex>` are accepted and converted.

==== `tag!`

**`S121`**::

A `<tag-literal>` value is written as zero or more characters, not starting with `<`, `=` or `>`, enclosed in `< >`.
Characters `"` and `'` are allowed but must each be properly paired and nested.

==== `binary!`

**`S122`**::
....
<binary-literal> ::= 2#{<base2-byte>*} | #{<hex>*} | 16#{<hex>*} | 64#{<base64-char>*}
....

where `<base2-byte>` is a group of 8 digits `0` or `1`, `<hex>` is defined in rule `S116`
and `<base64-char>` is a single character from the set `A-Z a-z 0-9 + /`; the individual elements within
the `#{ }` brackets (`<base2-byte>`, `<hex>` or `<base64-char>`) may be separated from the
brackets and from each other by whitespace.

Examples:
....
2#{00000001 00000010 00000011}
#{ 01 02 03 }
64#{AQID}
....

In order to help convert between the 3 representations (base2, base16 and base64),
the built-in functions `debase` and `enbase` have been defined. They each have
a refinement `/base` with an argument of 2, 16 or 64 (default).

Examples:
....
enbase #{010203}           -> "AQID"
enbase "^A^B^C"            -> "AQID"
enbase/base #{010203} 2    -> "000000010000001000000011"
debase "AQID"              -> #{010203}
....

==== `path!`

**`S123`**::
....
<path-literal> ::= <path-head>/<selector>
<path-head> ::= <word> | <path-literal>
<selector> ::= <integer> | <word> | :<word> | <paren>
....

Examples:
....
list/1/2
system/view/screens/2
list/:i
list/(i)
copy/part
....

=== Creation of values (`make`)

For some types, the values can *only* be introduced in a program as a
result of the `make` function. This section deals first of all with the types
for which that is the case, and with `map!` which has a "parallel"
syntactic form of its own. The `make` function can also be used
to construct values of other types. This is dealt with in the
latter part of the section. Note that `make routine!` is forbidden;
values of type `routine!` should be made by invoking the built-in
function `routine` which raises an error if called from the interpreter.

In this section, non-terminals like `<integer>` do not stand for
a literal integer but for a value (to be evaluated) of `integer!` type etc.
Note also that, as stated above, the first argument of `make` does not
have to be a `datatype!` value; if it is a value of another type,
that type is taken to be the desired type. This is not made explicit
in the following rules, except in the case of `make object!` where
an `object!` value as second argument has a different interpretation.
In the case of `make error!` only the type `error!` is allowed as first argument
_**See issue #2640**_.

In the following rules, the sign `Â°` signifies an optional element.

==== `typeset!`

**`S124`**::
....
<typeset> ::= make typeset! [<typeset-element>*]
<typeset-element> ::= <typeset> | <datatype>
....

Examples:
....
number!: make typeset! [integer! float! percent!]
scalar!: make typeset! [char! number! time! pair! tuple!]
....

Note that an empty typeset is allowed (`make typeset! [ ]`).

==== `hash!`

**`S125`**::
....
<hash> ::= make hash! <block> 
....
The contents of the `<block>` are copied (not deeply).

==== `vector!`

**`S126`**::
....
<vector> ::= make vector! <vector-spec>
<vector-spec> ::= <integer> | <block> | [ <type-and-size> <block>]
<type-and-size> ::= char! 8 | char! 16 | char! 32 |
                    integer! 8 | integer! 16 | integer 32! |
                    float! 32 | float! 64 | percent! 32 | percent! 64
....
The `<integer>` should be non-negative. It produces an empty `vector!` value with the prescribed
number of components of type `integer!` and size 32 being allocated _** and set to zero see issue #2596**_.
The components of the `<block>` should all have the same type `char! integer! float!` or `percent!`. 
If `<type-and-size>` are omitted, type is deduced from the contents of `<block>`, and size is
the default size (32 for `char!` and `integer!`, 64 otherwise). If `<block>` is empty, the assumed type
is `integer!` of size 32.

Examples:
....
make vector! []
make vector! [integer! 16 [1 2 3]]
make vector! [#"a" #"b" #"c"]`
....

==== `image!`

**`S127`**::
....
<image> ::= make image! <image-spec>
<image-spec> ::= <pair> | [<pair> <tuple>] | [<pair> <binary>] | [<pair> <binary> <binary>] 
....
If `<image-spec>` is `<pair>`, the image is created with the given dimensions, and with all pixels having color
`255.255.255` and transparency `0`. If a `<tuple>` is specified, this determines the color of all pixels,
transparency being `0`. If a single `<binary>` is specified, this should contain the array of colors of all pixels
(three bytes per pixel, stored by horizontal line), the transparency being `0`. The second `<binary>`, if present,
contains the transparency (one byte per pixel, in the same ordering).

Examples:
....
make image! 200x300, make image! [200x300 255.0.0]
make image! [2x2 #{FFFFFFCCCCCCBFBFBF0C0C0C} #{00000000}]
....

==== `bitset!`

**`S128`**::
....
<bitset> ::= make bitset! <binary> | make bitset! <bitset-spec> | charset <bitset-spec>
<bitset-spec> ::= <integer> | <char> | <string> | [<bit-position>*] | [not <bit-position>*]
<bit-position> ::= <integer> | <char> | <string> | <char> - <char> | <integer> - <integer>
....

A `<binary>` produces a `bitset!` value that is bit-by-bit equal to the `binary!` value.
The difference between `binary!` and `bitset!` is that `binary!` values have components
that are integers `0..255`, with 1-origin index, while `bitset!` values have components
that are `logic!` values (`true = 1, false = 0`), with 0-origin index.
The built-in function `charset` is defined as shorthand for `make bitset!`,
except that `<binary>` is not allowed as its argument. The `<bitset-spec>` that is
an `integer!` value produces an "empty" bitset (all bits set to false) of size the nearest
multiple of 8. In all other cases the `<bitset-spec>` provides a list of bit-position numbers,
or ranges of them, that are to be set to `true`. The `<char>` is interpreted as the Unicode Codepoint number.
A `string!` value is interpreted as the collection of all its component characters.
The length of the bitset is computed as the smallest multiple of 8 needed to fit the highest
bit number (0-origin). An "empty" bitset created by `[ ]` is 8 bits (one byte) long.
A `<bitset-spec>` that is a block starting with `not` produces the bit-by-bit complement of the bitset
produced by the following bit-position numbers, while actually storing only these bit-positions.
_**See issue #2609**_

Examples:
....
make bitset! 16
charset "abc"
charset [#"A" - #"Z" #"a" - #"z"]
....

The built-in function `complement?` will test if the bitset is a complemented one,
i.e. if its complement is what is actually stored.

==== `object!`

**`S129`**::
....
<object> ::= make object! <object-spec> | object <object-spec> | context <object-spec> |
             make <expression> <object-spec>
<object-spec> ::= <block>
....

The built-in functions `object` and `context` are defined as shorthand for `make object!`.
The `<expression>` must evaluate to a value of type `object!`.

If the first argument to `make` is `object!` this creates a new object as follows.
A new context is created and associated to the object. The words of the new context
(i.e. the fields of the object) are the words of all the `set-word!` values that are
(first-level) components of the `<object-spec>`. The corresponding values are set
to the unset value. The `<object-spec>` is bound to this context (see section
6.3.6). The bound block is then _executed_.
The `class` property of the newly created object is set to a unique integer.

If the first argument to `make` is an `object!` value, it serves as _prototype_.
A new object is created whose associated context is a copy of the prototype's context.
The `set-word!` values that are (first-level) components of the `<object-spec>`
are added to this context if they are not already present in that context.
The `<object-spec>` is then treated as in the previous case.
The `class` property of the new object is copied from the prototype.
The new object is said to be _derived_ from the prototype.

An additional built-in function `construct <spec>` creates an object,
but without executing the `<spec>` block. It has a refinement `/with`
to specify a base object which will be extended with the (unevaluated)
set-word/value pairs in `<spec>`. The words `true yes on false no off`
and `none` will be evaluated to their `logic!` or `none!` value, except if
the refinement `/only` is specified.

The built-in function `extend` takes an `object!` value as first argument
and a set of key-value pairs as second argument of type `block! hash!` or `map!`.
It will add the keys that are not present in the map, with their values,
and replace the values for those keys that are
already present. The keys and values are not evaluated.
_**It is not yet implemented**_

==== `error!`

**`S130`**::
....
<error> ::= make error! <error-spec>
<error-spec> ::= <integer> | <block> | <string>
....

For the fields of an `error!` value, and the structure of the error repertoire
(`system/catalog/errors`) see section 12.1.

If the `<error-spec>` is an `integer!` value, it is used to find values for the `type`
and `id` fields of the `error!` value which result in the `code` with that `integer!`
value. The values of these two fields are then bound as described in section 12.1.

If the `<error-spec>` is a `block!` value, it should either contain two `word!` values
which will be used for the `type` and `id` value of the intended `error!` value, or
it should be an `<object-spec>` containing at least `type:` and `id:` fields;
in the former case, the `type` and `id` values will be bound as described in section 12.1;
in the latter case, the `<block>` will be treated as described under rule `S129`;
note that also in this case, the `<block>` will be executed.

Except in the case where an `<object-spec>` is provided, any fields other than `type` and `id`
cannot be set by `make`. They should be set afterwards.

If the `<error-spec>` is a `string!` value, this will be used as `arg1` for the error with
`type: 'user id: 'message`. 

Note that `error!` values all have `class = 0`.

==== `function!`

**`S131`**::
....
<function> ::= make function! [<function-spec> <function-body>] | func <function-spec> <function-body> |
               has [<argument>*] <function-body> | does <function-body> | function <function-spec> <function-body>
<function-spec> ::= [<docstring>Â° <argument-spec> <return-spec>Â°]
<docstring> ::= <string>
<argument-spec> ::= <argument>* <optional-arguments>*
<argument> ::= <argument-name> <argument-doc>Â° | <argument-name> [<typeset-element>*] <argument-doc>Â°
<argument-name> ::= <word> | '<word> | :<word>
<argument-doc> ::= <string>
<optional-arguments> ::= <refinement> <argument-doc>Â° <argument>*
<refinement> ::= /<word>
<return-spec> ::= return: [<typeset-element>*]
<function-body> ::= <block>
....
For `<typeset-element>` see rule `S124`.

The `<docstring>` may be used to document the purpose and working of the function. Each `<argument-doc>`
may be used to document the purpose and usage of the associated  `<argument>`. When present, the type(set)s
specified for an `<argument>` will be used to check the type of the actual argument supplied.
Otherwise, `any-type!` will be assumed. Likewise, when present, the type(set)s of the `<return-spec>`
will be used to check the type of the result._**See issue #2589**_
The `<word>` s of the `<argument>` s following the `<refinement>`, if any,
are to be matched with actual arguments, if the function application (see rule `E110`)
specifies the corresponding `<selector>` (see rule `S123`).
The optional argument `/local` is conventionally used to list the local words of the function.
It is normally put after any other optional arguments (in fact the built-in `help` function
expects this to be the case). It is not usual, although not forbidden, to supply actual arguments
for these local words.

The built-in function `func` is defined as shorthand for `make function!`. The built-in function
`has` is defined as shorthand for a function without other arguments than local words, thus
`has [<arguments>] <block>` is equivalent to `func [/local <arguments>] <block>`.
The built-in function `does` is defined as shorthand for `func [ ]` (no arguments at all).
The built-in function `function` is similar to `func` but it adds all set-words
found in the body to the list of local arguments.

==== `routine!`

**`S132`**::

....
<routine> ::= routine <routine-spec> <routine-body>
<routine-spec> ::= [<docstring>Â° <routine-argument>* <locals>Â° <routine-return>Â°]
<routine-argument> ::= <word> <argument doc>Â° | <word> [<type-literal>] <argument-doc>Â°
<locals> ::= /local <routine-argument>*
<routine-return> ::= return: [<type-literal>]
<type-literal> ::= any-type! | <word-literal>
<routine-body> ::= <block>
....
For `<docstring>` and `<argument-doc>` see rule `S131`. Note that routines
do not have optional arguments, except `/local`. Note also that arguments
and return spec must have a single type specified. If the argument has no
type specified, `any-type!` is assumed._**see issue #2766**_ The `<word-literal>`
must refer to an existing Red type, which must be `integer! float!` or `logic!`,
or one that has a Red/System `structure!` alias defined that describes a value
slot of that type._**see issue #2642**_ The `<routine-body>` must contain valid Red/System code.

Values of type `routine!` may not occur in programs submitted to the interpreter.

The construction of routines requires a fairly deep knowledge of the Red runtime system
and the representation and storage of argument and result values.

==== `op!`

**`S133`**::
....
<op> ::= make op! <binary-function>
<binary-function> ::= <op> | <prefix-function>
....

For `<prefix-function>` see rule `S101`.

In contrast to `action!` and `native!` values which cannot be made by means of
`make`, the user may create new infix functions of two arguments (operators),
using `make op!`. The `<prefix-function>` should have exactly two arguments
and no optional arguments, except `/local`.

Example: `&&: make op! func [a b][all [a b]]`.

==== `map!`

A `map!` value can be produced both as grouped value and by `make`. The specification
is the same in both cases.

**`S134`**::
....
<map> ::= #(<map-spec>) | make map! [<map-spec>]
<map-spec> ::= <key-value-pair>*
<key-value-pair> ::= <key><value>
....

Each `<key>` should be a value of a type in `scalar!, any-word!` or `any-string!`.
All keys should be unique. If identical keys are encountered in the `<map-spec>` the value
corresponding to the last one encountered is taken. Keys of any type within `any-word!`
that do not differ in their symbol are considered identical for this purpose.
_**See issue #2577**_

Note that values of `logic!` and `none!` type are not allowed as keys. Nevertheless
`true false` and `none` may occur in `<key>` position. Since the constituents
of `<map-spec>` are not evaluated, these words will be treated as `word!` values.
The same is true if they occur in `<value>` position.

The built-in function `extend` takes a `map!` value as first argument
and a set of key-value pairs as second argument of type `block! hash!` or `map!`.
It will add the keys that are not present in the map, with their values,
and replace the values for those keys that are already present.
The keys and values are not evaluated.

==== other types 

* Making `integer!` and `float!` values from `logic!` values: `true -> 1/1.0, false -> 0/0.0` _**See issue 2644**_
* Making `logic!` values from `integer!` and `float!` values: `0/0.0 -> false, all else -> true`
* Making a `series!` value from an `integer!` or `float!` value: the `float!` value is truncated; the integer
or truncated number is used to create an empty `series!` value with storage for the given number of components reserved.
This does not apply to `image!` values.

=== Conversion of values (`to`)

Conversion is possible for selected combinations of _source_ and _target_ type.
The list given below is meant to be exhaustive. A summary table is available
elsewhere (see section 17).

Note that for each type that may occur as target type, there is a built-in function
defined as shorthand: `to-integer <spec>` for `to integer! <spec>` etc.

==== Target types `none!` and `unset!`

The functions `to-none` and `to-unset` yield a `none!` resp. `unset!` value
for any argument value.

==== Target type `logic!`

The function `to-logic` yields `true` for any argument value except `none`. Note that
`to logic! 0` yields `true` whereas `make logic! 0` yields `false`! _**See issue #2645**_

==== Target types in `any-string!`

The function `to-string` yields the same result as the built-in function `form` (see
section 11.1) except for

* `none!` values: conversion is not allowed
* `binary!` values: these will be decoded as UTF-8
* `any-list!` values: the function will apply `form` to each component and concatenate the results

The functions `to-file` etc. will perform the same conversion and yield
a result of the appropriate type.

==== Target types in `any-list!`

The function `to-block` yields a block with the argument as single component except
for

* `string!` values: first applies `load` (see section 11.1)
and applies `to-block` to the result
* `typeset!` values: yields a block with the individual types
* `any-block!` and `vector!` values: yields a block with the components
* `any-object!` and `map!` values: yields the same as `body-of`

The functions `to-paren` etc. will perform the same conversion and yield
a result of the appropriate type.

==== Target type `integer!`

The function `to-integer` is defined for

* `any-float!` and `time!` values: truncates the floating point value (seconds in the case
of `time!`) towards `0`
* `char!` values: yields the Unicode Code Point number
* `binary!` values: interprets the first 4 bytes as an integer (two's complement notation)
if there are fewer than 4 bytes, `#{00}` bytes are prepended
* `string!` values: yields the result of `load` or an error

==== Target types in `any-float!` and `time!`

The function `to-float` is defined for

* `integer!` values: yields the corresponding `float!` value
* `time!` values: yields the number of seconds
* `char!` values: yields the Unicode Code Point number as `float!` value
* `binary!` values: interprets the first 8 bytes as a floating point number (IEEE 754 binary64 format)
if there are fewer than 8 bytes, `#{00}` bytes are prepended
* `string!` values: yields the result of `load` or an error
* `any-list!` values: these should contain two components of type `integer!` or `float!`
the result is the first number times 10 to the power of the truncated second number

The function `to-percent` will perform the same conversions and yield a value of type `percent!.
The function `to-time` will do the same and yield a `time!` value; in this case,
the `any-list!` argument should contain two integer values and an integer or float value,
for hours, minutes and seconds respectively. 


==== Target type `char!`

The function `to-char` is defined for

* `number!` values: yields the Unicode Code Point with the (truncated) number
* `binary!` values: assumes UTF-8 encoding; decodes as many bytes as necessary to obtain a Unicode Code Point
* `any-string!` values: yields the first character

==== Target type `pair!`

The function to-pair is defined for

* `integer!` and `any-float!` values: yields the pair with two components equal to the (truncated) number
* `any-list!` values: these should contain two `integer!` or `float!` values;
yields the pair wih the (truncated) numbers as components

Note that a similar built-in function `as-pair` of two arguments is defined,
which creates a pair out of the arguments.

==== Target type `tuple!`

The function to-tuple is defined for

* `binary!` values: yields the first 12 bytes or fewer as tuple components; if only 1 or 2 bytes are 
present, components `0` are added
* `string!` values: yields the result of `load` or an error
* `any-list!` values: these should contain only `integer!` or `float!` values in the range `0..255`;
yields the first 12 components or fewer as tuple components;  if only 1 or 2 values are 
present, components `0` are added

==== Target type `binary!`

The function `to-binary` is defined for

* `integer!` and `any-float!` values: yields the corresponding 4 resp. 8 byte binary value
* `char!` values: yields the 1 to 4 byte binary value corresponding to the Unicode Code Point number
* `tuple!` values: yields the 3 to 12 bytes binary value corresponding to the tuple components
* `bitset!` values: yields the corresponding binary value
* `string!` values: yields the UTF-8 encoded binary value
* `any-list!` values: these should contain only `integer!` or `float!` values;
the binary equivalents are concatenated, using as few bytes as needed
for each `integer!` value and 8 bytes for each `float! value
* `image!` values: yields a binary value with 4 bytes for each pixel

==== Target types in `any-word!` `refinement!` and `issue!`

The function `to-word` is defined for:

* `char!` values: makes a `word!` value with that single character
* `logic!` and `datatype!` values: yields the word that refers to the value
* `string!` values: yields the result of `load` or an error

The functions `to-lit-word` etc. perform the same conversiosn and yield
the result as a value of the appropriate type.

Note that `to-word none` does not yield the word `none`, it raises an error.

==== Target type `image!`

The function `to-image` is defined for `object!` values that are _faces_ i.e.
derived from the `face!` object which describes a window in the Red GUI system.
It yields the face such as it would be rendered on the screen, as an `image!`
value. See further the documentation of the GUI system (reference in section
17).

==== Additional conversion functions

* `as-pair` takes two integer arguments and combines them into a `pair!` value,
thus `as-pair x y` is equivalent to `to-pair reduce [x y]` 
* `as-color` takes three integer arguments `0..255` and makes a `tuple!` value
representing a color (RGB)
* `as-rgba` does the same with four arguments, with additional transparency (RGBA)
* `as-ipv4` also has four arguments, and suggests an IPv4 address interpretation of the tuple
* `uppercase` and `lowercase` will work on values of type `char!` and `any-string!`
and convert them to upper case or lower case respectively; they use the
Unicode 7.0 case folding table (only character pairs with status C and S)

=== Casting of values (`as`)

The casting facility applies to most of the `series!` types, and makes use of the fact
that values of several different but related types have their component values
stored in identical fashion. Therefore a change of type can be performed without copying
any component values. Two groups of related types are involved: `block! paren! any-path`
on the one hand, and `any-string!` on the other. The type of the second argument shoul
d be in the same group as the (type of the) first argument. The result is a new value
of the desired type, pointing to the components of the old value.
Note the absence of `hash!` from the first group, explained by the fact that `hash!`
values are stored differently from other `any-block!` values.

=== Components of values

Composite values can have their components extracted and changed by various means.

==== Indexing

Values that are sequences (with types in `series!` and `bitset!`)
admit indexing by integers, and images also by pairs as coordinates.
The expression for this is `<path>` for extraction and `<path>: <expression>` for changing.
Built-in functions exist to perform the same operations. The correspondence is as follows:
if `v` is the value to be indexed and `i` is the index, then `v/i` is equivalent to `pick v i`
and `v/i: x` is equivalent to `poke v i x`. Note that for lexical reasons, a `pair!` value as index
must be enclosed in parentheses, thus if `v` is an image, the pixel at 2x2 is addressed as `v/(2x2)`.
Note that `pick` and `poke` additionally allow the `logic!` values `true` and `false` as indexes:
`true ~ 1` and `false ~ 2`.

Values of type `time! pair!` and `tuple!` also admit component selection
by "indexing". In the case of `time!` values, which are stored as a `float!` number
of seconds, this selection proceeds by calculation (`1 ~ hour`, `2 ~ minute`, `3 ~ second`).
For `pair!` , `1 ~ x` (horizontal dimension, left to right) and `2 ~ y` (vertical dimension,
top to bottom). As stated in section 4.2.3, component selection in values of direct types
cannot be used to change the component, only to extract it.
That is, only `<path>` and `pick` are allowed for these values.

The built-in functions `first second third fourth` and `fifth` are defined as `pick <expression> 1` etc.

==== Selection by "key"

This is possible both for values that are sequences (with types in `series!`,
but not `bitset!`) and for values of types `object! error!` and `map!`.
The expression for this is again `<path>` for extraction and `<path>: <expression>` for changing.
Built-in functions exist to perform the same operations. The correspondence is as follows:
if `v` is the value from which to select and `k` is the key, then `v/k` is equivalent to `select v k`
and `v/k: x` is equivalent to `put v k x`.

The semantics of selection are different in the two cases (sequences vs. objects/maps).
For sequences, a `find` action is performed on the components using the key,
which should be a single value of the right type, or itself a sequence of such values,
and the first position where the key is found is marked. The result is then
the component *after* the found key (single or sequence)._**See issue #2625**_ For the other types,
which contain key/value pairs, the result is the value corresponding to the given key.
In the case of `object!` and `error!` it is customary to call the keys _fields_.
Fields of `error!`values cannot be set.-**See issue #2554**_

Values of type `time! pair! email!` and `image!` also admit component selection
by specific words, and values of type `event!` have this as the only way of selection.
Again, for the direct types among them, only the `<path>` and `pick` forms are valid.

In case of `time! email! image!` and `event!`, the result is obtained by performing
a certain calculation.

* `time!` values: given a `float!` number of seconds, the `hour` and `minute` components
are the result of finding the whole number of `3600` seconds in the total, and then the
whole number of `60` seconds in the remainder; the `second` component is what remains after that
* `email!` values: the `user` component is the part before the `@` and the `host` component
is the part after the `@`
* `image!` values: the `size` component is the `pair!` value that holds the dimensions,
the `argb`, `rgb` and `alpha` components are the `binary!` sequences of RGBA, RGB and A values
respectively
* `event!` values: the components, which are explained in the Red GUi documentation
(see section 17) are calculated in an OS-dependent way

==== Overview table

....
type         indexed      built-in    key values or types                built-in
             components   functions                                      functions

time!        1 2 3        pick        hour minute second                 --
pair!        1 2          pick        x y                                --
tuple!       1 .. 12      pick        --                                 --
any-block!   integer!     pick poke   any-type!                          select put
vector!      integer!     pick poke   integer! char!                     select (put see issue #1960)
any-string!  integer!     pick poke   char! any-string! binary!          select (put see issue #1960)
+ email!                              host user                          --
binary!      integer!     pick poke   integer! char! any-string! binary! select (put see issue #1960)
image!       integer!     pick poke   size rgb alpha argb                --
             pair!        pick poke
bitset!      integer!     pick poke   --                                 --
             char!        pick poke   --                                 -- see issue #2523
map!                                  scalar! all-word! any-string!      select put
object!                               word!                              select put
error!                                code type id arg1 arg2 arg3        select
                                           near where stack
event!                                type face window offset key        --
                                           picked flags away?
                                           down? mid-down? alt-down?
                                           ctrl? shift?
....

=== Reflection on values

Values of some types have (internal) properties of interest to the user which may
usefully be exposed.

This concerns first of all `(any-)word!` values for which information on their
binding may be obtained by means of two built-in functions: `context?` and `index?`.
These are explained in section 6.2. _**See issue #2618**_. 

_**What about `owner`??** see issue #1957_

The function `complement?` is described in section 5.3.5.

The function `face?` tests if an object is derived of the `face!` object which is
explained in section 13.3.

_**Functions on vector! values have been requested see issue #2527**_

For values of type `object! error!` and `map!`, which consist of key/value pairs,
the collection of keys, that of values, and the set of key/value pairs may each
be obtained as a block by means of the built-in functions `words-of values-of`
and `body-of`. For convenience, `keys-of` is defined as synonym for `words-of`.
In addition, for objects there is the property `class-of` which yields
the unique number that is given to each object that is created from a `<spec>`, and is
inherited by objects _derived_ from it (see rule `S129` in section 5.3).

For `any-function!` values, one can obtain the full `<argument-spec>` through
the built-in function `spec-of` and the list of formal argument names through
the function `words-of` _**not yet implemented**_. For `function!` and `routine!` values, there is in
addition the function `body-of` which yields the function/routine body.

All functions `<property>-of <expression>` are shorthand for the general function
`reflect <expression> <property>` e.g. `words-of <expression>` is defined as `reflect <expression> 'words`. 

Note that the `help` built-in function is typically making good use of `spec-of`. 

=== Comparison of values

Red has the following operators and corresponding `native!` functions
for comparison of two values. Each of these operators/functions allows
arguments of any type, although in most cases the comparison may only
yield `true` if the two types are the same. Exceptions will be noted below.
The _equality_ functions, i.e. the first four, are defined for all types
of the first argument. The others (the _ordering_ ones) are only defined
for certain combinations of types. Also this will be noted.

....
    operator   native function

    =          equal?
    ==         strict-equal?
    =?         same?
    <>         not-equal?

    <          lesser?
    <=         lesser-or-equal?
    >          greater?
    >=         greater-or-equal?
....

==== Equality comparisons

The strictest equality test is `same?` which yields true only if the values
are of the same type and the two _value slots_ (see section 4.2.2)
have identical content. For values of direct types this comes down to simple equality,
but for values of other types it is quite possible to be equal but not the same
(e.g. two strings of identical content, but one a string literal and the
other the result of decoding a `binary!` value).

For two values to succeed the `strict-equal?` test, they have to be of the same
type and also have exactly the same value, i.e. not have the differences allowed
for the `equal?` test.

The `equal?` test ignores case differences in the spelling of words, characters
and strings, and in the case of floating point numbers, a very small difference
(1 in 10^16^) in actual value._**See also issues #2658, 2661 and 2661**_

For values of `any-block!` type, the `strict-equal?` and `equal?` tests apply pairwise
to the components. For `any-object!` the requirements are identity of field names
and (strict) equality of field values. If the components or field values are also of
`any-block!` or `any-object!` type, there is recursion involved, with cycle detection.
For values of `vector!` type, these tests also apply pairwise to the components. In
addition, the component type (`char! integer! float!` or `percent!`) must be the same.

In all cases, for the `equal?` test, the requirement of equal type is relaxed for several
combinations of types. Within each such combination, `equal?` will allow any two types
for the values to be compared:

* `char!` and `integer!` _**See issue #2650**_
* `integer! float!` and `percent!`
* `any-word!` and `refinement!` (note the absence of `issue!`)
* `any-string!`
* `any-object!` _**See issue #2657**_

==== Ordering comparisons

The following cases can be distinguished: 

* straightforward numerical ordering: `char! integer! float! percent!` and `time!`
* lexicographic ordering (case sensitive): `pair! tuple! any-word! refinement! issue!
vector! any-string! binary!` and `bitset!`
* lexicographic ordering (with recursion and cycle detection): `any-block!` and `object!`_**See issue #2663**_
* no comparison: `datatype! typeset! none! logic! image! map! error! function! routine!
action! native! op! handle! event!` and `unset!`.

As a rule, for ordering comparisons the types of the two values have to be the same._**See issue #2662**_
For `vector!` values, the component type (`char! integer! float!` or `percent!`) must also be the same.
However, as with equality, for some combinations of types this requirement is relaxed.

* `char!` and `integer!`
* `integer! float!` and `percent!`
* `any-word!` and `refinement!`
* `any-string!`

== Words, contexts and binding

=== Words

Red uses _words_ (values of type `word!`) to access values in much the same
way that other languages use variables. However, in Red, words do not
"store" values. Rather, a word _refers to a value_ in some _context_. i.e.
evaluating the word in that context yields the value. The word is said to be
_bound to_, or _in_ the context. Since functions, 
including built-in functions and operators, are also values in Red, the words
that refer to these values appear to work like keywords in other languages.

Thus all `word!` values have two important properties in this regard: their
symbol, that is their spelling (disregarding case), and the context they are
bound to. Something words *do not* have is a restriction on what values they
can refer to. In Red, values are strongly typed, but words, when used like
variables or keywords, are not.

For practical purposes, words are internally represented by three items:
a pointer to a context, an index in a symbol table which contains the symbol, 
and an index in the context which facilitates retrieving the value the
word refers to. Each occurrence of a word carries these three items
individually, and each occurence of a word with the same symbol can
therefore be bound to a different context, and refer to a different value.
Values of types `lit-word! set-word!` and `get-word!` (these types form
typeset `any-word!` with `word!`) have the same binding as the word
with the same symbol. Values of types `refinement!` and `issue!`,
although not bindable, may share the same symbol.

=== Contexts

A _context_ in Red is a collection of word/value pairs. The words in
this collection are all different, and the values are the values the words
refer to. One can think of it as a table composed of two columns,
where the first is a list of unique symbols and the second contains
a corresponding value for each. Each word that is bound in this context
has its symbol and the value it refers to, positioned in a row of the
table. The value can be retrieved by finding the symbol, or by using
an index (row number) in the table. Note that such tables actually exist
in the implementation as values of an internal pseudo-type.

There is one _global context_ containing all words that have passed lexical
analysis as well as those that have been pre-defined in the toolchain, and
which refer to values such as built-in functions and constants. Words in the
global context that are not pre-defined, are considered "unset", which is a
special kind of value, distinct from `none`.

In addition to the global context, any number of contexts may exist during
program execution. Every _object_ (value of type `object!`) gives rise to a
context, containing the field-name/value pairs of the object. From an
implementation viewpoint, an object is just a combination of a context
and a class. Every _error_ (value of type `error!`) is a specialized object,
and therefore also has a context associated with it. Every function 
(value of type `function!`) also gives rise to a context, which contains
the pairs of formal argument name and actual argument value to be used by 
the body of the function when it is executed.

The user may access the context of a word reflectively through the built-in
function `context?` which can be applied to any word and will yield the
context the word is bound to. Since contexts themselves are not values
of a type of the langauge, they are yielded in the form of an object or function
as the case may be. The context of a word which is a field of an error value
is yielded as an object having the same field names and values as the error.
The global context is yielded as the object `system/words`. The index of a word
in its context may be obtained through the built-in function `index?`.

=== Binding

Words are bound to contexts as a result of:

* lexical analysis
- notably when the program containing the words is submitted to the toolchain
- or through application of the built-in `load` function
- or when a string representing some values, including words, is submitted to the REPL
* applying the built-in `set` function
* evaluating a `set-word!` value
* evaluating a `make object! <spec>` construct
* making an `error!` value
* applying a function to its arguments
* applying the built-in `bind` function
* applying the built-in `in` function

Details of the binding process in these cases are given in the following sub-sections.

Note that a word bound to a context does not necessarily have a value. The built-in
function `value?` tests if it does.

==== Lexical analysis

Every lexeme that is recognized in the source text as representing
a value of a type in `any-word! refinement!` and `issue!`,
either by the operation of the toolchain or
-- at runtime -- by the `load` function, is bound to the global context,
and will initially not refer to any value in that context.

==== Setting words to values

The evaluation of `<word-literal>: <expression>` is treated in rule `E115`.
Equivalent to this is the application of the built-in function `set`:
`<word-literal>: <expression>` ~ `set '<word-literal> <expression>`.

The counterpart to `set` is `unset`: this will make the word argument
refer to the unset value.

==== Object creation

This is treated in rule `S129`.

==== Making an `error!` value

This is treated in rule `S130` and in section 12.1.

==== Function application

This is treated in rule `E110`.

==== Built-in `bind` function

The built-in function `bind` has two arguments: a word (or block of words)
and a context.

The function will try to change the binding of a single word or
of all words in a block, and will return the (modified) word or block.
It operates on values of type `word! lit-word! set-word!` and `get-word!`
(for brevity, called "words" in the rest of this section),
and will treat them at any depth within the block and its sub-blocks
(including values of type `paren! path! lit-path! set-path! get-path!` and `hash!`).

For each word to be treated it will search for the presence of an equally spelled
word in the given context, which is supplied in the form of a word
(whose context will be used), or of an object or error value or a function.
If an equally spelled word is found, the function will change the context
of the treated word to that given context and will adapt the index of the word;
otherwise, the word is left untouched.

With the `/copy` refinement the `block!` argument will be deep-copied before it
is modified.

A major application of this function is the binding of the formal arguments
of a function, as they occur within the function body, to the context which
contains the actual argument values. See evaluation rule `E110`.

==== Built-in `in` function

The built-in function `in` has two arguments: an `object!` or `error!` value
and a word.

It will bind the word to the object or error context, and yield the word thus
bound as result.

== Evaluation rules

General remark: operator application has precedence over application of other functions
and over set-word target evaluation. Note that in Red all operators (values of type `op!`)
are binary infix functions. See further rule `E112`.

The operation of the toolchain will result in the evaluation of the Red source text presented
to it. The user can, at runtime, achieve evaluation of a (fragment of) Red source, i.e. Red data,
by invoking the built-in function `do`. If this is presented with a string argument. it will
invoke `load` (see section 11.1) first, and then evaluate the result. If the argument is
a block, the block will be _executed_ as described in rule `E100`.

=== Passive types

**`E100`**:: For all values of passive types evaluation yields the value itself.
This is called the **identity rule**.

Note that `block!` is one of the passive types. Thus evaluation of a block
leaves the block unchanged. The term _execution of a block_ will be used to
indicate sequential evaluation of the components of the block; the result of this
execution is the result of the last evaluation, if any, and the unset value otherwise.
See also the section 7.5.

=== Decaying types

These are `lit-word!` and `lit-path!`.

**`E101`**:: Evaluating a `lit-word!` value results in its `word!` counterpart.

**`E102`**:: Evaluating a `lit-path!` value results in its `path!` counterpart.

The built-in function `quote` will yield its argument, which may be of any type,
without evaluating it. In particular `quote <word-literal>` is equivalent to `'<word-literal>`,
and `quote <path-literal>` is equivalent to `'<path-literal>`.

=== Active types

==== `word!` type

**`E103`**:: Evaluating a `word!` value proceeds as follows:
. Determine the context to which the word is bound._**can it happen that there is no context?**_
. Obtain the value that the word refers to in this context.
. Determine the type of this value.
.. If the type is `unset!` raise an error and yield the unset value as result.
.. If the type is in `any-function!` _apply_ the function (see rules `E110-114`).
.. Otherwise, the result is the value referred to.

Note: there are cases in which a `<word>` is not to be evaluated, e.g. when it occurs as
`<key>` or `<value>` in a `<map-spec>`, or when it is an actual argument to a function
where the formal argument is a `lit-word!`. In these cases, the predefined words `true false`
and `none` as well as the type names will be interpreted as `word!` values rather than as
`logic!` or `none!` values. To represent values of the desired type in such cases one may use
the generalized value construction syntax: `#[true], #[false], #[none]` etc.

The built-in function `get` with a `word!` argument applies the above rule except when the type of
the value referred to is in `any-function!` in which case no _function application_ occurs.
Moreover, with the refinement `/any` no error occurs if the `word!` value refers to the unset value.

==== `get-word!` type

**`E104`**:: Evaluating a `get-word!` value proceeds as follows:
. Determine the context to which the word is bound._**can it happen that there is no context?**_
. Obtain the value that the word refers to in this context.
. Determine the type of this value.
.. If the type is `unset!` yield the unset value as result.
.. Otherwise, the result is the value referred to.

Note that the difference with evaluating a `word!` value is that no errors are raised
and that a function value is not applied but is itself yielded as result.

==== `set-word!` type

**`E105`**:: Evaluating a `set-word!` value outside an `<object-spec>` or a `<map-spec>`
has the effect that the `<word>` in its context
is made to refer to the value obtained by evaluating the next expression. An error occurs
if no expression is following or if the value obtained is unset. The result of the evaluation
is the value obtained. As a consequence, set-words may be "chained", thus: `a: b: c: 1`
is equivalent to `a: 1 b: 1 c: 1`.

As stated before, the alternative to `<word-literal>: <expression>` is `set <word> <expression>`.
The built-in function `set` has a refinement `/any` which will ensure that
no error occurs if the expression yields the unset value.

==== `paren!` type

**`E106`**:: The evaluation of a `paren!` value proceeds by the evaluation of its component
values. The result is the value obtained from the last evaluation. This is similar to the
execution of a block. The following table compares parens and blocks.
....
expression          result of evaluation    comment
[1 + 2 3 + 4]         [1 + 2 3 + 4]         block! is passive type
do [1 + 2 3 + 4]      7                     do forces execution
(1 + 2 3 + 4)         7                     paren! is active type
quote (1 + 2 3 + 4)   (1 + 2 3 + 4)         quote inhibits evaluation
....

==== `path!` type

Recall the structure of `path!` values:

**`(S123)`**::
....
    <path> ::= <path-head>/<selector>
    <path-head> ::= <word> | <path>
    <selector> ::= <integer> | <word> | :<word> | <paren>
....

**`E107`**::

The evaluation of a `path!` value proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. If there is no next element which is a `<selector>`, use the value of the `<path-head>`
as intermediate result and go to step 4.
.. Otherwise, determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, this will yield
a component of the composite value as described in step 3.
.. If the result is of `file!` or `url!` type and there are one or more
next elements each of which is a `<selector>`, the result is currently
a new file or url composed as `<path-head>/<selector>/...` _**but see issue #2578**_
.. If the result is a value of `any-function!` type, each following
`<selector>`, if any, should be an actual refinement of the function, i.e a `word!` value,
corresponding to one `<refinement>` present in the `<argument-spec>` of the function.
Apply the combination of the result and the actual refinements according
to the rules for values of function types (see section 7.4).
.. Otherwise, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, the intermediate result is the component of the composite value
at the index given by the `integer!` value (0-origin for `bitset!` values,
1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
go to step iv. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the composite value is of
indirect type (except `image!` and `email!`), an intermediate result is obtained by
applying the built-in function `select`
with as arguments the composite value and the `<selector>`.
.. If the `<selector>` is a `<word>`, and the composite value is of
direct type, `image!`, `email!` or `event!`, an intermediate result is obtained
as explained in section 5.6.2.
.. Otherwise, the path is in error.
.. If a further `<selector>` is present, use the intermediate result just obtained
as evaluated `<path-head>` and go to step 2.
. Determine the type of the intermediate result just obtained.
.. If the type is `unset!` raise an error and yield the unset value as result.
.. If the type is in `any-function!` apply the function (see rules `E110-114`).
.. Otherwise, the result is the intermediate result just obtained.

The built-in function `get` with a `path!` argument applies the above rule except when the type of
the value referred to is in `any-function!` in which case no _function application_ occurs.
Moreover, with the refinement `/any` no error occurs if the `path!` value refers to the unset value.

==== `get-path!` type

See also rule `E107`.

**`E108`**::
The evaluation of a `get-path!` value proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. If there is no next element which is a `<selector>`, use the value of the `<path-head>`
as intermediate result and go to step 4.
.. Otherwise, determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, this will yield
a component of the composite value as described in step 3.
.. If the result is of `file!` or `url!` type and there are one or more
next elements each of which is a `<selector>`, the result is currently
a new file or url composed as `<path-head>/<selector>/...` _**but see issue 2578**_
.. If the result is a value of `any-function!` type, no following
`<selector>` is allowed and the result is the function value.
.. Otherwise, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, the intermediate result is the component of the composite value
at the index given by the `integer!` value (0-origin for `bitset!` values,
1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
go to step iv. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the composite value is of
indirect type (except `image!` and `email!`), an intermediate result is obtained by
applying the built-in function `select` with as arguments the composite value
and the `<selector>`.
.. If the `<selector>` is a `<word>`, and the composite value is of
direct type, `image!`, `email!` or `event!`, an intermediate result is obtained
as explained in section 5.6.2.
.. Otherwise, the path is in error.
.. If a further `<selector>` is present, use the intermediate result just obtained as 
evaluated `<path-head>` and go to step 2
. Determine the type of the intermediate result just obtained.
.. If the type is `unset!` yield the unset value as result.
.. Otherwise, the result is the intermediate result just obtained.

==== `set-path!` type

**`E109`**::
The evaluation of a `set-path!` value proceeds as follows:

. Start with the first path component. Evaluate this `<path-head>`, which is a `<word>`,
as per rule `E103`.
. If there is no next element which is a `<selector>`, use the value of the `<path-head>`
as intermediate result and go to step 4.
.. Otherwise, determine the type of the evaluated `<path-head>`.
.. If the result is a value of composite type (except `file!` and `url!`),
and there is a next element which is a `<selector>`, proceed to step 3.
.. Otherwise, the path is in error.
. Determine the type of the `<selector>`.
.. If the `<selector>` is a `<get-word>` or a `<paren>`, evaluate it first,
use the value obtained as `<selector>` and go to the beginning of step 3.
.. If the `<selector>` is an `<integer>`, and the composite type is not `map!`
or `any-object!`, an intermediate result is determined which is the position
of the component at the index given by the `integer!` value
(0-origin for `bitset!` values, 1-origin for values of all other composite types).
.. If the `<selector>` is an `<integer>` and the composite type is `map!`
the result is obtained as in step iv hereafter. If the `<selector>` is an
`<integer>` and the composite type is `any-object!` the path is in error.
.. If the `<selector>` is a `<word>`, and the composite value is of
indirect type (except `image!` and `email!`), an intermediate result is determined which is
the position of the first component found by applying the built-in function `find`
with as arguments the composite value and the `<selector>`.
.. If the `<selector>` is a `<word>`, and the composite value is of
type `image!`, an intermediate result is obtained which is the
position of the component found as as explained in section 5.6.2.
.. Otherwise, the path is in error.
.. If a further `<selector>` is present, use the component at the position just determined,
as evaluated `<path-head>` and go to step 2
. Replace the component at the position determined, by the value obtained
by evaluating the next expression.
An error occurs if no expression is following or if the value obtained is unset.
The result of the evaluation is the value obtained.
As a consequence, set-paths may be "chained", also with set-words, thus: `a/b/c: d/e/f: g: 1`
is equivalent to `a/b/c: 1 d/e/f: 1 g: 1`.

Moreover, the alternative to `<path-literal>: <expression>` is `set <path> <expression>`.
The built-in function `set` has a refinement `/any` which will ensure that
no error occurs if the expression yields the unset value.

=== Function types

Values of `any-function!` type must be applied together with any
actual refinements (`word!` values that are found as `<selector>` in a `path!`
value whose `<path-head>` evaluates to the `any-function!` value). 

Recall the basic structure of the `<argument-spec>`, which is valid, with
some limitations,  for all values of `any-function!` type except `op!` values:

**`(S121)`**::
....
<argument-spec> ::= <argument>* <optional-argument>*
<argument> ::= <argument-name> | <argument-name> [<typeset-element>*]
<argument-name> ::= <word> | '<word> | :<word>
<optional-argument> ::= <refinement> <argument>*
<refinement> ::= /<word>
....

_**TBD: apply**_

==== `function!` type

**`E110`**::

The application of a `function!` value (also called _function call_
or _function application_) proceeds as follows:

. If the function does not have any arguments (optional or not), execute
the body of the function to yield the result of the function.
. If the function has any arguments (optional or not), create a context specific
to this function value, with all the words (including values of type
`lit-word! get-word!` and `refinement!`) occurring in the `<argument-spec>`.
Make all these words initially refer to `none`.
.. Evaluate as many subsequent expressions as needed to obtain values corresponding
to the non-optional arguments, except that when the `<argument-name>`
is a `'<word>` or `:<word>`, do not evaluate the corresponding expression but yield its first `<value>`.
_**See issue #2622**_
If the `<argument-name>` is `:<word>`, do not raise an error if this value is unset.
Make the `<word>` of each `<argument name>` refer to the corresponding value.
Check the type of each value against the type(set)s specified for the argument.
.. If actual refinements are present, match each of them with the corresponding `<refinement>`
in the `<argument-spec>`. Make the `<word>` of the `<refinement>` refer to `true`.
Furthermore, process each `<argument>` following the `<refinement>`
as in the previous sub-step, evaluating the necessary expressions and inserting the values obtained in the context.
.. Bind the body of the function to the context (see section 6.3.6).
.. Execute the body of the function to yield the result of the function.
Check the type of the resulting value against the type(set)s specified with `return:`, if any.

Note that the order of the expressions to be supplied for the optional arguments is dictated
by the order of the actual refinements present, *not* by the order of the `<refinement>` s
in the `<argument-spec>`.

==== `action!` type

**`E111`**::

As stated before, the definitions of the actions are fixed at the start of
the toolchain's operation. No new actions can be made by the user. In fact,
during initialization of the toolchain, each action name (`word!` value) is made to refer
to an `action!` value that consists of a spec similar to the `<argument-spec>` of a function,
and an _action number_. Also, a table is prepared that contains the addresses of the
primary Red/System functions that handle the actions, indexed by the action number
(their names are the action names followed by `*`). Subsequently, a dispatch table (_action table_) is
prepared that contains entries for each combination of action number and type of first argument 
for which the action is defined. As suggested before, this initialization will fill the
entry with the address of a Red/System function handling the action for this combination,
or with the address already determined for the combination of action and _parent type_
of the given type (_inheritance_).

The application of an `action!` value then proceeds as follows:

. From the action number, determine the `<argument-spec>` of the action.
. Evaluate one or two expressions corresponding to the non-optional arguments.
Evaluate expressions as needed for the optional arguments corresponding to
the refinements specified, if any, and determine default values for the others.
. Call the primary Red/System function that handles the action 
with all the arguments in standard order. This will do the following:
.. Determine the type of the first argument and look up the appropriate entry in the dispatch table.
.. Call the Red/System function that the entry refers to, with all the arguments
.. This Red/System function will check the type of the second argument, if any, and determine
its operation on the basis of the (combination of the) argument type(s).

As with `function!` evaluation, the order of the expressions to be supplied
for the optional arguments is dictated by the order of the actual refinements present,
*not* by the order of the `<refinement>` s in the `<argument-spec>`.

==== `op!` type

**`E112`**::
A value of `op!` type is always derived from a value of another `any-function!` type:
`function! action! native!` or `routine!`. Moreover, an `op!` value always has exactly
two arguments and no refinements. Therefore, the application proceeds as for the
function etc. it is derived from, with the expression that precedes the `op!` value
corresponding to the first argument and the expression following the `op!` value
corresponding to the second one.

==== `native!` type

**`E113`**::

As stated before, the definitions of the native functions are fixed at the start of
the toolchain's operation. No new natives can be made by the user. In fact,
during initialization of the toolchain, each native name (`word!` value) is made to refer
to a `native!` value that consists of a spec similar to the `<argument-spec>` of a function,
and a _native number_. Also, a table is prepared that contains the addresses of the Red/System
functions that implement the native functions, indexed by the native number
(their names are the native names followed by `*`).

The application of a `native!` value then proceeds as follows:

. From the native number, determine the `<argument-spec>` of the native function.
. Evaluate as many expressions as correspond to the non-optional arguments.
Evaluate expressions as needed for the optional arguments corresponding to
the refinements specified, if any, and determine default values for the others.
. Call the primary Red/System function that handles the native function
with all the arguments in standard order. This will call upon the full
repertoire of runtime functions, notably the interpreter for executing the blocks
of the control functions (`if`, `either`, `repeat` etc.).

As with `function!` evaluation, the order of the expressions to be supplied
for the optional arguments is dictated by the order of the actual refinements present,
*not* by the order of the `<refinement>` s in the `<argument-spec>`.

==== `routine!` type

Recall the basic structure of `<routine-spec>`:

**`(S132)`**::
....
<routine-spec> ::= [<routine-argument>* <locals>Â° <routine-return>Â°]
<routine-argument> ::= <word> | <word> [<type-literal>]
<locals> ::= /local <routine-argument>*
<routine-return> ::= return: [<type-literal>]
....

**`E114`**::
Values of `routine!` type may not occur in programs submitted to the interpreter.

When compiling, the toolchain will convert the routine into a _Red/System function_ as follows:

. The `<routine-spec>` is converted into a Red/System function specification block
by changing every Red type mentioned in it, except `integer! logic!` and `float!`
to the corresponding Red/System `struct!` alias that describes the value slot,
thus `string!` becomes `red-string!` etc.
. An argument without a type is given Red/System alias `red-value!` which corresponds
to `any-type!`.
. The `<routine-body>` (which is a block of Red values) becomes the body of
this Red/System function, and will be treated as Red/System code.

The function thus constructed becomes part of the intermediate Red/System code
that the toolchain produces internally for compilation into machine code,
and the application of the function will proceed according to the Red/System rules.

=== Blocks: reduction and selective evaluation

As stated before, evaluation of a block leaves it unchanged. _Execution of a block_
is the term used to indicate sequential evaluation of the expressions in the block,
yielding as a result the result of the last evaluation, if any, and the unset value
otherwise. Two built-in functions are available to evaluate expressions in a block
and preserve the results in a block.

The built-in function `reduce` applied to a block yields a new block, with
as components all the results of evaluating the block's constituent expressions,
in the same order.

Example:
....
reduce [1 + 2 3 + 4]        ->  [3 7]   ; reduction
do [1 + 2 3 + 4]            ->  7       ; compare with execution
....

It is also possible to selectively evaluate the block's expressions: the built-in function
`compose` will only evaluate those components that are of type `paren!`. With refinement
`/deep`,`compose` will also act on nested blocks. With refinement `/only`, `compose` will
evaluate a block as a block, instead of yielding its constituent expressions separately.

Example:
....
compose [1 + 2 (3 + 4)]          ->  [1 + 2 7]     ; evaluation only within parens
compose [[(1 + 2)] (3 + 4)]      ->  [[(1 + 2)] 7] ; inner blocks are untouched
compose [([1 + 2]) (3 + 4)]      ->  [1 + 2 7]     ; evaluation of a block yields the components 
compose/only [([1 + 2]) (3 + 4)] ->  [[1 + 2] 7]   ; with /only, a block stays a block
compose/deep [[(1 + 2)] (3 + 4)] ->  [[3] 7]       ; with /deep, inner parens are also evaluated
....

The built-in function `collect` will execute the block which is its argument
and yield a new block as result which contains all values resulting from expressions
that are argument to the function `keep` invoked inside the argument block.

Example:
....
collect [repeat i 10 [if even? i [keep i ** 2]]] -> [4 16 36 64 100]
....

The _shortcut evaluation_ functions `any` and `all` have a block as argument;
they will evaluate the expressions one by one; `any` will stop at the first
one whose value is not `false` or `none` and yield that as result;
if there is no such expressions it will yield `none`;
`all` will stop at the first one which is `false` or `none`
and yield `none` as a result; if there is no such one
it will yield the result of evaluating the last one. Note that `any [ ]`
and `all [ ]` both yield `none`.

== Numerical and logical computation

=== Basic arithmetic operations

Red makes available the usual _arithmetic operations_ through `+ - * /` as operators
(values of type `op!`) and their prefix counterparts: `add subtract multiply divide`.
In addition, there are operators and prefix functions for exponentiation (`**` or `power`),
modulo (`//` or `modulo`) and remainder (`%` or `remainder`). Enquiry functions are:
`sign? positive? negative? zero? even? odd? NaN?`. The unary minus function is only represented
by a prefix function `negate`, not by an operator, since these have always two arguments.
Lastly, there are functions for determining the absolute value (`absolute`),
the maximum and minimum of two numbers (`max min`) and for rounding (`round`).

The arity (number of arguments) and the argument and result types for these
functions are as follows.
....
function            arity   argument type(s)                      result type
                            operand 1           operand 2

+ - * / // %          2     scalar! vector!     scalar! vector!   see next table
**                    2     number!             integer! float!   integer! float!
NaN?                  1     number!                               logic!
sign?                 1     number! time!                         integer!
positive? negative?   1     number! time!                         logic!
zero?                 1     scalar!                               logic!
even? odd?            1     number! char!                         logic!
negate                1     number! time! pair!                   same as operand  see issue #1262
absolute round        1     number! time! pair!                   same as operand see issue #1262, 1267
max min               2     scalar!             scalar!           same as greatest/smallest
                                                                  operand (operand 1 if equal)
....

The result types for the 6 arithmetic operations `+ - * / // %` are detailed in the following table.
When no result type is mentioned, all 6 operations are forbidden. Individual restrictions are
mentioned through notes (1) to (7). The operations on values of type `pair! tuple!` and `vector!`
take place component-by-component. When the two operand types are different,
the result type is determined as (in decreasing order of precedence):

. the higher dimension type
. the higher precision type
. the type of operand 1

_**See issue #2776**_
....
operand 2 -> char!    integer! float!   percent! time!    pair!    tuple!     vector!
operand 1
char!        char!    char!    char!                                          vector!
             (1)      (1)      (1)                                            (1)(6)

integer!     integer! integer! float!   float!   time!    pair!    tuple!     vector!
             (1)                                          (1)(2)   (1)(2)(3)  (1)(6)

float!       float!   float!   float!   float!   time!    pair!    tuple!     vector!
             (1)                                          (1)(2)   (1)(2)(3)  (1)(6)

percent!              percent! percent! percent! time!    pair!    tuple!     vector!
                                                          (1)(2)   (1)(2)(3)  (1)(6)

time!                 time!    time!    time!    time!                        vector!
                                                 (4)(5)                       (1)(6)

pair!                 pair!    pair!    pair!             pair!
                      (1)      (1)      (1)               (1)

tuple!                tuple!   tuple!   tuple!                     tuple!
                      (1)      (1)      (1)                        (1)

vector!     vector!   vector!  vector!  vector!  vector!                      vector!
            (1)(6)    (1)(6)   (1)(6)   (1)(6)   (1)(6)                       (1)(7)

(1) modulo not allowed
(2) divide not allowed
(3) subtract not allowed
(4) divide has float! result
(5) multiply not allowed
(6) result has element type of vector operand see also issue #2216
(7) operand 1 and 2 must have same element type
....


Note that `round` has a number of refinements:
....
/to             => Return the nearest multiple of the scale parameter
   scale    [number!] "Must be a non-zero value"
/even          => Halves round toward even results
/down          => Round toward zero, ignoring discarded digits. (truncate)
/half-down     => Halves round toward zero
/floor         => Round in negative direction
/ceiling       => Round in positive direction
/half-ceiling  => Halves round in positive direction
....

The functions `max min` are also defined for `series!` arguments. See section 9.

=== Higher mathematical functions

This concerns first of all the familiar functions `exp` for raising
`e = 2.718281828459045` to a power, the logarithms `log-e log-2 log-10`,
and the square root `sqrt`. Furthermore the trigonometric functions
`sin cos tan asin acos atan atan2`, and the functions `random` and
`checksum`.

The arity (number of arguments) and the argument and result types
for these functions are as follows. Result types are only indicated
if different from argument types.
....
function                       arity argument type(s)                    result type

exp log-e log-2 log-10 sqrt     1    number!                             float!
sin cos tan asin acos atan      1    float!
atan2                           2    float!
random                          1    logic! scalar!
checksum                        2    binary! string! file!               binary!
                                     word!
....

Notes: all trigonometric functions take an argument in radians, except `atan2`
which takes two `float!` arguments representing `y` and `x` coordinates.
The function `random` yields a random value between zero and its argument
value or one of `false` and `true` for `logic!`; for `pair!` and `tuple!` values
it operates per component; it is also defined for `series!` arguments (see section 9).
The `word!` argument to `checksum` indicates the method; allowed are
`MD5 SHA1 SHA256 SHA384 SHA512 CRC32 TCP`.

=== Set-theoretical functions

The following functions operate on values that can be conceived as representing
_sets_ of other values; this concerns some series types: `block! hash! string!`,
as well as `bitset!` and `typeset!`.

The functions `intersect union difference` and `exclude` have two arguments
of one of the types mentioned, and yield a result of the same type. The function
`unique` has one argument of type `block! hash! string!`, and again yields
a result of the same type. The operation of these functions follows from their names.

=== Bitwise functions

The following functions operate on the bit patterns underlying Red values
of suitable types.

The function `complement` yields the bit-by-bit complement, thus for integers
it yields the two's complement, e.g. `complement 2` is `-3`.
The operators `and or xor` with prefix counterparts `and~ or~ xor~` operate
bit-by-bit on their arguments.

Three bit-shift operators are defined on integers, with positive integer shift count:

* `<<` for left shift: highest bits are shifted out, zero bits are added to the right
* `>>` for right shift: lowest bits are shifted out, highest bit is duplicated
* `>>>` for "logical" shift: lowest bits are shifted out, zero bits are added to the left

The arity (number of arguments) and the argument and result types
for these functions are as follows.

....
function     arity  argument type(s)

complement     1    integer! bitset! typeset! binary! see issue #1263, 1267, 1956
and or xor     2    integer! char! pair! tuple! bitset! typeset! binary! vector!
<< >> >>>      2    integer!
....

Note that `and or` and `xor` on values of type `bitset!` and `typeset!` yield
the same result as `intersect union` and `difference` (see previous section).  

=== Logical functions

The bitwise functions `complement and or xor` are also applicable to
`logic!` values; on these values, `not` is equivalent to `complement`.
On values of other types, `not` will always yield `false` except on
`none`, where it will yield `true`.

Note that `and or xor` evaluate both their arguments. In many programming
situations, it is preferable to use the _shortcut evaluation_ functions
`any` and `all`, which only evaluate subsequent arguments if an earlier one
is `false` or `none` for `any` or `not none` (i.e.`true`) for `all`.
See section 7.5.

== Operations on values of indirect types

=== Introduction

This concerns series, bitsets, maps, objects and errors.

As explained earlier, series in Red, as values of indirect types, have their
components stored contiguously, but separately from the value slot that
stores the "series value" itself. This value slot only contains the following
information: a pointer to the components storage, and the current index.
The components storage itself keeps track of the length of the series
i.e. the index of the last component.

Bitsets are stored similarly to series, but have a restricted number of operations.

Maps, objects and errors all have _fields_, and share a number of operations, although
there are also differences to be taken into account.

=== Series: positioning and navigation

The following functions of a series value yield a new series value with the index
modified:
....
function                   new index

head <series>              1
tail <series>              length + 1
at <series> <expression>   (index calculated from <expression>)
skip <series> <expression> current index + (offset calculated from <expression>)
next <series>              current index + 1
back <series>              current index - 1
find <series> <expression> index of first occurrence of (component or sub-series)
....

Here the `<expression>` argument of `at` and `skip` should evaluate to an integer.
For `image!` values, a `pair!` value is also allowed. This will be converted to
a regular index. The `<expression>` argument of `find` may be a single component
value or a sub-series. This function is not defined on `image!`values.

For all series, if the index becomes smaller than `1` or greater than `length + 1`,
it will be fixed at `1` or `length + 1`. If `find` does not have a match, its result is `none`.

Note that `find` has a rich set of refinements:
....
/part     => Limit the length of the search
    length   [number! series!] 
/only     => Treat a series search value as a single value
/case     => Perform a case-sensitive search
/same     => Use "same?" as comparator
/any      => TBD: Use * and ? wildcards in string searches
/with     => TBD: Use custom wildcards in place of * and ?
    wild     [string!] 
/skip     => Treat the series as fixed size records
    size     [integer!] 
/last     => Find the last occurrence of value, from the tail
/reverse  => Find the last occurrence of value, from the current index
/tail     => Return the tail of the match found, rather than the head
/match    => Match at current index only and return tail of match
....

The following enquiry functions are available: `head? tail? length? index?`. The function
`empty?` is a synonym for `tail?`. The built-in function `offset?` yields the difference
of the `index?` values of its two `series!` arguments. 

Note: for programming convenience, the functions `length?` and `empty?` (but not `tail?`)
accept `none` as an argument, yielding `none` as result.

=== Series: extraction and modification of components

The following built-in functions have been described in section 5.6:
`pick poke select put first second third fourth fifth`.

The function `select` has the same set of refinements as `find` (see previous section)
with the exception of `/tail` and `/match`.

The function `last` may be seen as shorthand for `first back tail`.

These functions create a new series value, with a new series value slot:
....
function                      result

copy <series>                 copy of the series
extract <series> <integer>    copy of the series with 1st component and every nth following one
split <series> <delimiter>    a block of sub-strings split at the delimiter(s)
....

For `split`, the `<series>` must be of type `any-string!`, and the
`<delimiter>` may be a single character, a bitset representing
a choice of characters, or a string.

The following functions modify the series _in place_, i.e. they modify
the series value slot to point to the changed series. With the exception of
`take` and `alter`, their result is the changed series itself. These functions
are not defined on `image!` values.

....
function                      operation                                 resulting position of series

reverse <series>              order of components reversed                at head
sort <series>                 components in increasing/decreasing order   at head
random <series>               components in random order                  at head
clear <series>                components removed till tail                at tail
remove <series>               current component removed                   unchanged, i.e. before next component
take <series>                 current component removed                   (unchanged, result is component value)
change <series> <expression>  current component replaced
                              by value of <expression>                    after current component
replace <series> <pattern>    components equal to <pattern>               at head
     <expression>             replaced by value of <expression>
alter <series> <expression>   if value of expression in <series>          (at head, result is true if appended,
                              remove it, else append                      else false)
insert <series> <expression>  insert value of <expression>                before current component
                              before current component
append <series> <expression>  insert value of expression at tail          at head
repend <series> <expression>  insert reduced value of expression at tail  at head
trim <series>                 spaces removed from string                  at head
                              or none from block or hash value            see also issue #2521
pad <series>                  string padded on right side with spaces     at head
....

The function `sort` is only defined on values of type `string! binary! vector! block! hash! paren!`.
Since it has quite a number of options, here is the full specification:
....
DESCRIPTION: 
     Sorts a series (modified); default sort order is ascending. 
     SORT is an action! value.
ARGUMENTS:
     series       [series!] 
REFINEMENTS:
     /case        => Perform a case-sensitive sort.
     /skip        => Treat the series as fixed size records.
        size         [integer!] 
     /compare     => Comparator offset, block or function.
        comparator   [integer! block! any-function!] 
     /part        => Sort only part of a series.
        length       [number! series!] 
     /all         => Compare all fields.
     /reverse     => Reverse sort order.
     /stable      => Stable sorting.
RETURNS:
     [series!]
....

The following functions take two series as arguments:
....
function   operation                                 result and position

swap       swap components at current positions      first series at head   see also issue #1961
move       remove current component of first series  first series before next component
           and insert it before current component
           of second one
max        compare series lexicographically          greater series before current component
min        compare series lexicographically          smaller series before current component
....

Also these functions are not defined on `image!` values.

Note: for programming convenience, the following functions take `none` as argument, yielding `none` as result:
`clear find remove select take`.

=== Operations on bitsets

The following operations on bitsets have been described in earlier sections: `complement?` (5.3.5)
`pick poke` (5.6), `intersect union difference exclude` (8.3), and `complement and or xor` (8.4).
The following built-in functions are also defined on bitsets, with the following semantics:
....
insert <bitset> <bitset-spec>       set the bits at the indicated positions to true
append <bitset> <bitset-spec>       idem
remove/part <bitset> <bitset-spec>  set the bits at the indicated position to false
clear <bitset>                      set all bits to false
negate <bitset>                     complement 
copy <bitset>                       yields a copy of the bitset
find <bitset> <bitset-spec>         yields true if all indicated bits are set
length? <bitset>                    yields the number of bits reserved for the bitset
....

For `<bitset-spec>` see section 5.3.5. If this is a block, it may not contain `not`.

=== Operations on maps

The following operations on maps have been described in section 5.6: `put select`.
The following built-in functions are also defined on maps, with the following semantics:
....
clear <map>              removes all key-value pairs from the map
copy <map>               yields a copy of the map
extend <map> <items>     adds key-value pairs from <items> (a block, hash or map)
                         replacing the value if the corresponding key is already present
find <map> <value>       yields true if key indicated by <value> exists, else none
                         <value> must be of type scalar!, any-word! or any-string!
length? <map>            yields the number of key-value pairs
....

=== Operations on objects and errors

== Control

=== Selective execution

The following functions enable conditional execution of one or more block:
`if unless either case switch`. The definitions may be presented as follows:

....
<if>          ::= if <condition> <true-block>
<unless>      ::= unless <condition> <false-block>
<either>      ::= either <condition> <true-block> <false-block>
<case>        ::= case [ <case-alt>* ] | case/all [ <case-alt>* ] 
<case-alt>    ::= <condition> <true-block>
<switch>      ::= switch <expression> [ <switch-alt>* ]
                  | switch/default <expression> [ <switch-alt>* ] <default-block>
<switch-alt>  ::= <label> <true-block> | <label> <switch-alt>
<condition>   ::= <expression>
<label>       ::= <value>
....

The `<condition>` is evaluated and is satisfied unless it yields `false` or `none`,
except for `unless`, where the condition _should_ yield `false` or `none`.

With refinement `/all`, all conditions of the `<case>` are tested; otherwise testing
stops after the first one that is satisfied, if any.

The `<label>` values of the `<switch>` are _not_ evaluated. The selection condition
is satisfied at the first alternative where the value of the `<expression>` is equal to a `<label>`.
With refinement `/default`, the `<default-block>` will be executed if none
of the conditions is satisfied.

The functions `if` `unless` `case` and `switch` without `/default` yield `none` if
no condition is satisfied.


=== Repeated execution (loops)

The available constructs are the following:
....
<forever>     ::= forever <body>
<while>       ::= while <condition> <body>
<until>       ::= until <condition>
<loop>        ::= loop <integer> <body>
<repeat>      ::= repeat <word> <integer> <body>
<foreach>     ::= foreach <counter> <series> <body>
<forall>      ::= foreach <word> <body>
<remove-each> ::= remove-each <counter> <series> <condition>
<condition>   ::= <block>
<counter>     ::= <word> | <block>
<body>        ::= <block>
....

Semantics:

* `forever`: the `<body>` is executed until an exception is encountered
(see section 12).
* `while`: the `<condition>` is executed and if does not yield `false` or `none`,
the `<body>` is executed after which the `<condition>` is again executed etc.
* `until`: the `<condition>` is executed as long as it does not yield `false` or `none`.
* `loop`: the `<body>` is executed an integer number of times.
* `repeat`: the `<body>` is executed repeatedly with the `<word>` assuming values
from 1 to the integer. Note that the `<word>` is _not_ local to the loop,
i.e. there is no separate context for the `repeat` loop.
* `foreach`: the `<counter>` may be a word or a block of words. The `<body>` is executed
repeatedly with the word(s) being set to subsequent components of the series.
The word(s) are again not local to the loop.

Example:
....
foreach [name phone] ["John" "123-4567" "Mary" "345-6789"] [print [name phone]]
....
* `forall`: the `<body>` is executed repeatedly starting with the word referring
to the head of the series; on each subsequent iteration the word will refer to the
series at the next position (see `next` function in section 9.2).

Example:
....
b: [1 2 3 4 5 6]
forall b [if odd? b/1 [prin b/2]]
....
this will print `246`

* `remove-each`: the `<condition>` is executed on each iteration, with the word(s)
of the `<counter>` being set as in `foreach`. If the condition is satisfied,
the components of the series that the word(s) currently refer to, are removed from the series.

The result of `forever` is that of the exception that causes its interruption.
For the other functions, unless an exception has occurred, the result is the unset value
for `while loop` and `remove-each`, and the result of the execution of the body
for the remaining ones.

=== Interrupting execution

The built-in functions `break continue exit return` are described
in section 12.

The built-in functions `halt` and `quit` or `q` stop the execution
of the program. _**Difference??_** The built-in function `quit-return`
delivers its integer argument as status code back to the Operating System.

=== Special execution cases

The built-in function `comment` evaluates its argument and yields
the unset value as result. It is mostly used to insert multi-line
comments, with a multi-line string as argument or to "comment out"
blocks of code. Care has to be taken that the argument is a valid Red expression,
even though its evaluation is intended to have no effect.

The built-in function `also` has two arguments. It evaluates both one after the
other, and yields the result of the first one, using `get/any`.

== Input/output

=== Conversion from/to textual representation

The built-in function `load` will convert textual input (or its binary UTF-8 encoded
equivalent), specified as its argument, to one or more values by calling upon
the lexical/syntactic analysis facilities of the toolchain. The result is either one
value or a block of values.

There are two built-in functions for converting values to readable strings:
`form` will produce a basic representation intended for human readers, and `mold`
will produce strings that are guaranteed to re-produce the original expressions when
submitted to `load`. As stated in section 5.4 the
operation of `form` is the same as that of `to-string` with the exception of
argument types `none! binary!` and `any-list!`. Especially values of the
last group of types, as well as values of types `vector!` and `object!`
merit special attention since the are converted to strings showing
the essentials without conserving type information.

Examples:
....
load "1"                  -> 1                      ; string analyzed as representing an integer
load "1 + 2"              -> [1 + 2]                ; load produces a block for more than one value
load "[1 2 3]"            -> [1 2 3]                ; one (grouped) value detected
load #{5B31203220335D}    -> [1 2 3]                ; same input as binary value

form ()                   -> ""                     ; unset! value
form #{414243}            -> "#{414243}"            ; to-string gives "ABC"
form [1 2 3]              -> "1 2 3"                ; block brackets omitted
form quote (1 2 3)        -> "1 2 3"                ; parens also omitted
form make hash! [1 2 3]   -> "1 2 3"                ; hash property not shown
form make vector! [1 2 3] -> "1 2 3"                ; vector property not shown
form object [a: 1]        -> "a: 1"                 ; object property not shown
mold [1 2 3]              -> "[1 2 3]"              ; load is guaranteed to recognize this
mold make hash! [1 2 3]   -> "make hash! [1 2 3]"   ; hash property conserved
mold make vector! [1 2 3] -> "make vector! [1 2 3]" ; vector property conserved
....

The built-in function `save` will apply `mold` to the expression which is its
second argument. If the destination specified as its first argument is a string,
it will append the result of `mold` to that string. If the destination
is a `binary!` value, it will first create a UTF-8 encoded `binary!` value
out of the result of `mold` and append that value to the destination .
_**See issue #2668**_

For `block!` and `paren!` values (not `hash!` _**see issue #2686**_),
the user can control the way they are presented by `mold` by inserting
line feed characters (`U+000A`) before selected components. The built-in
function `new-line` with a `block!` or `paren!` first argument will
set a _new-line marker_ in the value slot of the current component of
its argument (if the second argument evaluates to `true`) or clear this marker
if the second argument evaluates to `false`.

Example:
....
b: [1 2 3 4]
forall b [new-line b true]
print mold b
....
gives
....
[
    1 
    2 
    3 
    4
]
....

The state of the new-line marker may be tested with the built-in function
`new-line?` which has a `block!` or `paren!` argument, and yields `true`
or `false`.

=== Conversion from/to other representations

The built-in functions `load` and `save` each have an `/as` refinement
with a `word!` argument: the value `none` indicates Red code (Red data)
and makes `load` and `save` operate as already described;
other values implemented are `png jpeg bmp gif`; for each of these values
`load` will accept binary data in the indicated format and yield an `image!`
value, and `save` will take an `image!` value and produce the encoded binary
value. The necessary decoding and encoding routines are stored in `system/codecs`.
This is a block of pairs: `<word><object>`, where the `<word>` indicates
the encoding e.g. `jpeg`, and the corresponding `<object>` has the following
content:
....
    key             value type   content

    title           string!      (not filled in) 
    name            word!        'JPEG
    mime-type       block!       [image/jpeg]
    suffixes        block!       [%.jpg %.jpeg %.jpe %.jfif]
    encode          routine!     routine [img [image!] where [any-type!]][...]
    decode          routine!     routine [data [any-type!]][...]
....

=== Full specification of load and save

Because of their importance, the complete specification of the built-in functions
`load` and `save` is given here.
....
USAGE:
     LOAD source
DESCRIPTION: 
     Returns a value or block of values by reading and evaluating a source 
     LOAD is a function! value
ARGUMENTS:
     source       [file! url! string! binary!] 
REFINEMENTS:
     /header      => TBD
     /all         => Load all values, returns a block. TBD: Don't evaluate Red header
     /trap        => Load all values, returns [[values] position error]
     /next        => Load the next value only, updates source series word
        position     [word!] "Word updated with new series position"
     /part        => 
        length       [integer! string!] 
     /into        => Put results in out block, instead of creating a new block
        out          [block!] "Target block for results"
     /as          => Specify the type of data; use NONE to load as code
        type         [word! none!] "E.g. json, html, jpeg, png, etc"

USAGE:
     SAVE where value
DESCRIPTION: 
     Saves a value, block, or other data to a file, URL, binary, or string 
     SAVE is a function! value
ARGUMENTS:
     where        [file! url! string! binary! none!] "Where to save"
     value         "Value(s) to save"
REFINEMENTS:
     /header      => Provide a Red header block (or output non-code datatypes)
        header-data  [block! object!] 
     /all         => TBD: Save in serialized format
     /length      => Save the length of the script content in the header
     /as          => Specify the format of data; use NONE to save as plain text
        format       [word! none!] "E.g. json, html, jpeg, png, redbin etc"
....

=== Printing

The built-in function `prin` will take an expression
and send a string to the standard output device. If the expression
is not a block, the string is the result of applying `form` to the
result of evaluating the expression; in the case of a block, the individual
expressions it contains are evaluated and converted by `form` and separated by
single spaces. The built-in function `print` calls `prin` and outputs
a line feed afterwards.

The built-in function `probe` will call `mold` and then `print`, and
yield its argument as a result. This is useful for debugging intermediate
results; note that `print` itself will yield the unset value.

Examples:
....
print [1 + 2 3 + 4]    ; prints "3 7" and yields unset
probe [1 + 2 3 + 4]    ; prints "[1 + 2 3 + 4]" and yields [1 + 2 3 + 4]
....

=== File and URL I/O

The built-in function `read` will read a string from a file on an external
device which is indicated by a `file!` or `url!` value as its argument. The content
is assumed to be UTF-8 encoded unless the refinement `/as` is used,
which has a `word!` argument indicating the character encoding _**What is allowed??**_.
If the refinement `/lines` is used, the content will be split into lines
at the line feed character (`U+000A`); a preceding carriage return (`U+000D`),
if present, will be accounted for. If the refinement `/binary` is used,
the content will be read as a `binary!` value and not be decoded.

The built-in function `load` also accepts a `file!` or `url!` value
indicating a text or binary file. It will read the content of the file
and treat it as indicated above. 

The built-in function `write` will send a string or `binary!` value which is
its second argument to a file on an external device which is indicated
by a `file!` or `url!` value as its first argument.  If the second argument
is not a string or `binary!` value, it will first be passed to `mold`.
The resulting string will be UTF-8 encoded (as by `to-binary`)
unless the refinement `/as` is used, which has a `word!` argument indicating
the character encoding _**What is allowed??**_.
If the refinement `/append` is used the output will be written at the end of the file.
If the refinement `/lines` is used, and the value to be written is a block,
the components of the block will be written with a line feed after every component.
The refinement `/binary` ensures that a line feed character (`LF`, `U+000A`)
present in the source is not translated to an OS-specific character combination
(e.g. `CRLF`, `U+000D + U+000A`) but is output as a single `LF`.

The built-in function `save` also accepts a `file!` or `url!` value indicating
a text or binary file. It will send its result to that file.

TBD
....
A    close
A    create
A    modify
A    open
A    open?
A    query
A    update
....

=== File system functions

A `file!` value may indicate either a file or a _directory_ (some
Operating Systems call this a _folder_). The conventions for
Red file names are:

* the device name, if any, and the names in the directory hierarchy
are separated by a `/` character (some operating systems use
the `\` character for the same purpose)
* a file name starting with a `/` character represents an _absolute path_,
otherwise the path is _relative_ to the _current working directory_
* a file name ending in a `/` character represents a directory
* the abbreviations `.` for current directory and `..` for one level
higher directory are honored; the built-in function `clean-path`
will do the necessary substitutions (_normalization_)

The built-in function `to-local-file` translates a Red `file!` value
into the appropriate string for the target OS. The built-in function
`to-red-file` will take a string indicating a file in the target OS
and produce the equivalent Red `file!` value. These functions will
not do normalization.

Examples: 
....
to-local-file %/C/Projects/Red/programs/ -> "C:\Projects\Red\programs\"
to-red-file "C:\Projects\Red\programs\"  -> %/C/Projects/Red/programs/
....

The current working directory is stored in `system/options/path`.

The following built-in functions deal with the file system:

* `exists?` will yield `true` if the file indicated by its `file!` argument
exists in the file system, and `false` otherwise
* `suffix?` yields the suffix (extension) of a file, or `none` if there is no suffix
* `size?` will yield the size of the file in bytes
* `dir?` will yield `true` if the `file!` value indicates a directory
and `false` otherwise
* `what-dir` will yield the current working directory as a `file!` value
* `cd` or `change-dir` will set the current working directory to the argument
which may be a `file!`, `word!` or `path!` value; the argument will first be
_normalized_
* `pwd` will print the current working directory
* `list-dir` will list the contents of the directory that is its argument
(type `file!` `word!` or `path!`) in as many columns as will fit the screen;
it has a refinement `/col` to specify the number of columns;
it also has several near-synonyms: `ls` and `dir` will call `list-dir` without
refinement and `ll` will call it with 1 column specified; all three will use the
current working directory if they are called with no argument;
note that `read <directory>` will yield a block with the content of the directory
* `make-dir` will create the directory that is indicated by its `file!` argument;
if this contains more than one directory level, and the `/deep` refinement
is specified, the intermediate directory or directories will also be created
* `clean-path` will normalize its `file!` argument to an absolute path
where `.` and `..` are eliminated
* `split-path` will take a `file!` argument and yield a block of two
`file!` values: the last file or directory in the path, preceded by the
directory containing that file or directory (or `%./` if the argument
was a single file or directory)
* `delete` will take a `file!` argument and delete the file indicated;
the result is `true` if the operation was succesful, and `false` otherwise

TBD
....
A    rename
....
=== Console functions

The _console prompt_ and the string preceding the result of the user input
are available as `system/console/prompt` and `system/console/result`. Their
initial values are `">> "` and `"== "` respectively.

The built-in function `ask` will print its argument at the console prompt
and wait for user input until a line feed (`U+000A`) is received;
the string before the line feed will be yielded as result.

The built-in function `input` is shorthand for `ask ""`.

The built-in function `read-clipboard` will return the clipboard content as a string
and `write-clipboard` with a string argument will set the clipboard content.

=== URL functions

The function `browse` with a `url!` argument will open the system default browser
at the URL that is indicated by its argument.

== Exceptions

Two kinds of exceptions (exceptional situations which disturb the normal
evaluation process) may be distinguished: _error exceptions_  or _errors_,
which arise in the course of evaluation because of inappropriate (combinations
of) values, and _user exceptions_ that are raised or "thrown" on conditions
determined by the user. An intermediate case is the _user error_ which is
also raised on conditions determined by the user but which is treated
like an error value.

=== Errors

==== Composition

Errors are values of type `error!` that can be produced as a result of
any evaluation; they are specialized objects with a fixed number of fields,
that contain the necessary information for identifying the nature and the place
of the error. A prototype error value is contained in `system/standard/error`.
As also shown in section 5.6 the fields are:
....
name     type           content

code      integer!       unique identifying number
type      word!          characterizes a group of errors
id        word!          identifier for the error within the group       
arg1      any-type!      additional information for the error message
arg2      any-type!      id.
arg3      any-type!      id.
near      block!         program fragment
where     any-type!      value whose evaluation triggered the error 
stack     integer!       machine address
....

Any field except `type` and `id` can also be `none`. If `arg1` is `none`
`arg2` and `arg3` will also be none`; likewise, if `arg2` is `none`,
`arg3` will also be `none`.

The `type` field may contain one of the following words: `throw note syntax
script math access user internal`.

There is a fixed _repertoire_ of errors; identifying information
and (parametrized) error messages for each possible error are stored
in the object `system/catalog/errors`. This has the following sub-objects,
whose field names correspond to the contents of the `type` field
of the error value and which group related errors:
....
system/catalog/errors/...        code field  type field

throw                              0        "Throw Error"
note                             100        "note"
syntax                           200        "Syntax Error"
script                           300        "Script Error"
math                             400        "Math Error"
access                           500        "Access Error"
user                             800        "User Error"
internal                         900        "Internal Error"
....

As indicated in the table, each of the sub-objects has two fixed fields:
`code` which contains the base number for the codes of the individual
errors, and `type` which is a string that can be used in forming the
error message; this serves to sufficiently characterize the group.
Each sub-object has furthermore a number of fields, whose names
correspond to the `id` field of the error value, and which identify
the individual error. E.g. the `math` group has fields `zero-divide, overflow`
and `positive`. The contents of each of these fields is either a string,
which is a complete error message, or a block of strings and instances
of `:arg1, :arg2` and `:arg3`, which needs to be bound 
to the context of the error value, in order for the values of
`arg1` to `arg3` to be inserted; the block then can be used
to construct the error message. The full list of possible
errors is shown in section 15.

When the error value is produced,
the word which is the value of its `type` field is bound such that
it refers to the sub-object whose field name is that word;
also, the word which is the value of `id` field is bound such that
it refers to the error message (string or block) within that sub-object
whose field name is that word. _**See issue #2633**_ Thus the following code will produce
the full message information for an error value, say `err`:
....
either err/arg1                             ; test if insertion is necessary
[
    reduce bind (get err/id) (in err 'id)   ; yields a block of strings and values
][
    get err/id                              ; yields a string
]
....

Note the use of the `in` built-in function to obtain the context of the
error value.

Examples:
....
system/catalog/errors/math is an object! of value:
     code             integer!  400 
     type             string!   "Math Error" 
     zero-divide      string!   "attempt to divide by zero" 
     overflow         string!   "math or number overflow" 
     positive         string!   "positive number required" 
system/catalog/errors/access is an object! of value:
     code             integer!  500 
     type             string!   "Access Error" 
     cannot-open      block!    ["cannot open:" :arg1] 
     invalid-utf8     block!    ["invalid UTF-8 encoding:" :arg1] 
     no-connect       block!    ["cannot connect:" :arg1 "reason: timeout"]
....

The `code` for each individual error is the base number + the ordinal number
of the error in the sub-object, e.g. for `no-connect` it is `502`.
_**Currently it is 504, is this correct? See issue #2628**_

==== Raising and interception

Errors are normally raised by the compiled code or by the interpreter,
as the case may be, but they can also be raised by the built-in
function `cause-error`. The raising of an error will break off program
execution, unless it is intercepted by `try` or `attempt`.

The built-in function `try <block>` will execute the block and if there is
an error, it will yield that error value; otherwise it will yield the value
resulting from the execution. The built-in function `attempt <block>` will
apply `try` and if the result is an error value, it will yield `none`.

=== User exceptions

In contrast to errors, a user exception is not a value of the language,
but a call of a built-in function, which interrupst program execution
and may cause resumption at another place in the code, or result in
breaking off the execution like an unintercepted error does.

Three types of user exceptions exist:

* interruption of repeated execution (_loops_)
* interruption of function body execution
* "throws"

==== Interruption of loops

Red has a number of _loop_ constructs which cause repeated execution
of a block (see section 10.2).
In each of these, the block (_loop body_) may contain calls of the built-in functions
`break` and `continue`. A call of `break` will interrupt execution
of the body and resume directly after it. The result of `break` and thus
of the evaluation of the loop is the unset value. A call of `break/return <expression>`
will yield the value of the `<expression>` as a result of evaluating the loop.
A call of `continue` will interrupt execution of the body and resume
at the end of the body, potentially resulting in further cycles of execution.
Calls of these functions outside a loop body raise an error.

==== Interruption of function body execution

A call of the built-in function `exit` will interrupt execution of the
function body and resume in the code directly after the call.
The result of `exit` is the unset value. A call of the built-in function
`return <expression>` will also interrupt execution
and yield the value of the `<expression>` as a result of the function body execution.
Calls of these functions outside a function body raise an error.

==== Throws

A _throw_ is a call of the built-in function `throw <expression>` which will
interrupt execution and resume just after a corresponding call
of the built-in function `catch`, yielding the value of the `<expression>` as a result.

A _catch_, i.e. a call of the built-in function `catch <block>`,
will execute the block and if there are no throws during the execution,
it will yield the result of the execution as a value. If within the block,
including within the body of any function called within the block,
to any depth, there is a throw, the result of the catch
will be the value yielded by this throw.

For more control, `throw` has a refinement `/name` with a `word!` argument.
Correspondingly, `catch` has a refinement `/name` with as argument
a word or a block of words. A _named throw_ will only be reacted on
by a _named catch_ which has (amongst others) this name as argument,
or by a catch without a name. Other encompassing `catch` calls
will let it pass through.

If a throw is not caught by a catch, it will result in an error. 

==== Interception by `try` and `attempt`

The built-in function `try` (see 12.1.2) has
a refinement `/all`, allowing it to catch all possible forms of exceptions,
including `break`, `continue`, `exit` and `return` misuses as well as
uncaught throws. The built-in function `attempt`, which calls `try`,
has a refinement `safer` which causes it to use `try/all`.

== Additional facilities

=== Preprocessor

The Red preprocessor is a dialect of Red, enabling transformation of Red source code
using a specific layer on top of regular Red language code. Transformations are achieved
by inlining preprocessor keywords (called _directives_) inside Red source code.

These directives will be processed:

* when the Red source code is compiled
* when the Red source code is executed by the `do` built-in function with a `file!` argument
* when the `expand-directives` built-in function is called on a `block!` value

The preprocessor is invoked after the lexical/syntactic analysis phase, so it processes
Red values, and not the source code in text form.

Directive categories:

* _conditional directives_: include code depending on the result of an expression
* _control directives_: control the behavior of the preprocessor.
* _macros_: transform code using functions, enables more complex transformations

Directives are denoted by specific `issue!` values (starting with a `#` character).

When a directive is processed, it is replaced by the resulting value it returns
(some directives do not return anything, so they are just removed).
That is how transformations of source code is achieved.

Note: Red/System has its own preprocessor, which is similar, but low-level
and applied to the source code in text form.

Further explanations are provided in separate documentation;
see section 17.

=== Parse

The _parse dialect_ is an embedded Domain Specific Language for parsing input series
using grammar rules. It is an enhanced member of the Top Down Parsing Languages (TDPL) family.
Parse's common usages are for checking, validating, extracting, modifying
input data and implementing embedded and external DSLs.

Parse's core principles are:

* advance input series by matching grammar rules until top-level rule failure
(returning `false`) or input exhaustion (returning `true )
* ordered choices (e.g. in `["a" | "ab"]` rule, the second one will never succeed)
* rules composability (unlimited)
* limited backtracking: only input and rules positions are backtracked,
other changes remain
* two modes: string-parsing (for example: external DSL) or block-parsing (for example: embedded DSL)

Further explanations are provided in separate documentation;
see section 17.

=== GUI System

The Red/View component is a graphic user interface system for the Red programming language.
The design goals are:

* data-oriented, minimal API
* tree of objects as programming interface
* realtime or deferred synchronization between the object tree and the display system
* make two-way binding trivial to support
* ability to have different backends, across different platforms
* support OS, third-party and custom widget sets
* low performance overhead

The virtual tree is built using _face objects_, i.e. objects derived from the standard
object `face!`. Each face object maps to a graphic component on the display in a two-way
binding. The built-in function `view` takes a face object as argument and displays it
together with all face objects depending on it. Face objects can be made directly
by the user (`make <object> ...`) or created by using the Visual Interface Dialect (VID)
which allows to specify each graphic element to display. VID code is processed by
the `layout` function.

Draw is a dialect (DSL) that provides a simple declarative way to specify 2D drawing operations.
Such operations are expressed as lists of ordered commands (using blocks of values),
which can be freely constructed and changed at run-time. Draw blocks can be rendered
directly as an `image!` value using the `draw` built-in function, or as a part of
a graphic element created by `view/layout`.

Further explanations are provided in separate documentation;
see section 17.

=== Reactivity

Red objects are capable of triggering asynchronous events in response
to changes in their components, thus enabling _reactive programming_.

The most prominent application of this in the toolchain is in the GUI engine
where the `face!` objects are reactors.

Further explanations are provided in separate documentation;
see section 17.

=== Environment and OS-related functions

The operation of these functions is dependent on the particular Operating System
(OS) running on the target computer.

The following functions allow interaction with the set of _environment variables_
that most Operating Systems maintain:

* `list-env` will yield a `map!` value with string keys and values for all variables
for the current process
* `get-env` with a string or word argument will yield the current value of the named variable
* `set-env` with a string or word argument and a string value as second argument will set
the named variable to the value, or unset it if the second argument in `none`

The function `now` yields the current date and time as a Red `date!` value _**for the moment
only `now/time` is available yielding the time as a Red `time!` value**_.

The function `wait` with a `number!` or `time!` argument will wait for the specified time
or number of seconds.

The function `call` will execute an OS shell command to run another process. Its argument
is a `string!` value representing a shell command or a `file!` value representing
an executable file.

=== Help facilities

These facilities owe much to the homoiconicity of Red, and to the systematic
use of _docstrings_ (see section 5.3.8).

An overview of available facilities is obtained by typing `help` at the console.
This gives the following output:
....
    Use HELP or ? to view built-in docs for functions, values 
    for contexts, or all values of a given datatype:

        help append
        ? system
        ? function!

    To search for values by name, use a word:

        ? pri
        ? to-

    To also search in function specs, use a string:

        ? "pri"
        ? "issue!"

    Other useful functions:

        ??     - Display a word and its value
        probe  - Print a molded value
        source - Show a function's source code
        what   - Show a list of known functions or words
        about  - Display version number and build date
....

== Pre-defined words list

=== constants
....
  characters
    comma
    CR
    dbl-quote
    dot
    escape
    lf
    newline
    null
    slash
    sp
    space
    tab
  floating point numbers
    pi
  logic! values
    false
    no     = false
    off    = false
    on     = true
    true
    yes    = true
  none! value
    none
  strings
    crlf
    font-fixed
    font-sans-serif
    font-serif
    p-indent
    value
  tuples (RGB color values)
    aqua
    beige
    black
    blue
    brick
    brown
    coal
    coffee
    crimson
    cyan
    forest
    glass
    gold
    gray
    green
    ivory
    khaki
    leaf
    linen
    magenta
    maroon
    mint
    navy
    oldrab
    olive
    orange
    papaya
    pewter
    pink
    purple
    reblue
    rebolor
    Red
    sienna
    silver
    sky
    snow
    tanned
    teal
    transparent
    violet
    water
    wheat
    white
    yello
    yellow
....
=== datatypes
....
    action!
    binary!
    bitset!
    block!
    char!
    datatype!
    email!
    error!
    event!
    file!
    float!
    function!
    get-path!
    get-word!
    handle!
    hash!
    image!
    integer!
    issue!
    lit-path!
    lit-word!
    logic!
    map!
    native!
    none!
    object!
    op!
    pair!
    paren!
    path!
    percent!
    point!
    refinement!
    routine!
    set-path!
    set-word!
    string!
    tag!
    time!
    tuple!
    typeset!
    unset!
    url!
    vector!
    word!
....
=== typesets
....
    all-word!
    any-block!
    any-function!
    any-list!
    any-object!
    any-path!
    any-string!
    any-type!
    any-word!
    default!
    immediate!
    internal!
    number!
    scalar!
    series!
....
=== functions

The functions are classified by functionality: 

* enquiry, i.e. properties of types and values (see sections 4.4 and 5.7)
* making values (see sections 5.3 and 7.5)
* converting values (see sections 5.4 and 5.5)
* comparison (see section 5.8)
* evaluation and binding (see sections 6 and 7)
* numerical and logical computation (see section 8)
* series manipulation (see section 9)
* control (see section 10)
* input/output (see section 11)
* exception handling (see section 12)
* help facilities (see section 13.6)
* preprocessor (see section 13.1)
* parse (see section 13.2)
* GUI System (see section 13.3)
* reactivity (see section 13.4)
* environment and OS-related (see section 13.5)

The letter in front of each word gives the type: `A` for `action!`, `N` for `native!`,
`O` for `op!`, `R` for `routine!` and `F` for `function!`. When a function is directly
derived from another one, the two are written on one line, and the most frequently
used one is written first.

==== enquiry
....
F    action?
F    any-block?
F    any-function?
F    any-list?
F    any-object?
F    any-path?
F    any-string?
F    any-word?
F    binary?
F    bitset?
F    block?
F    body-of
F    char?
F    class-of
N    complement?
N    context?
F    datatype?
F    email?
F    error?
R    event?
F    face?
F    file?
F    float?
F    function?
F    get-path?
F    get-word?
F    handle?
F    hash?
F    image?
F    immediate?
A    index?
F    integer?
F    issue?
F    keys-of
F    lit-path?
F    lit-word?
F    logic?
F    map?
F    native?
F    none?
F    number?
F    object?
F    op?
F    pair?
F    paren?
F    path?
F    percent?
F    refinement?
A    reflect
F    routine?
F    scalar?
F    series?
F    set-path?
F    set-word?
F    spec-of
F    string?
F    tag?
F    time?
F    tuple?
N    type?
F    typeset?
F    unset?
F    url?
F    values-of
F    vector?
F    word?
F    words-of
....
==== making values
....
F    charset
F    collect
N    compose
N    construct
F    context
N    does
N    extend
N    func
N    function
N    has
A    make
F    object
N    reduce
F    routine
....
==== converting values
....
N    as
R    as-color
R    as-ipv4
N    as-pair
R    as-rgba
N    debase
N    enbase
N    lowercase
A    to
F    to-binary
F    to-bitset
F    to-block
F    to-char
F    to-email
F    to-file
F    to-float
F    to-get-path
F    to-get-word
F    to-hash
F    to-image
F    to-integer
F    to-issue
F    to-lit-path
F    to-lit-word
F    to-logic
F    to-map
F    to-none
F    to-pair
F    to-paren
F    to-path
F    to-percent
F    to-refinement
F    to-set-path
F    to-set-word
F    to-string
F    to-tag
F    to-time
F    to-tuple
F    to-typeset
F    to-unset
F    to-url
F    to-word
N    uppercase
....
==== comparison
....
O    <        N    lesser?
O    <=       N    lesser-or-equal?
O    <>       N    not-equal?
O    =        N    equal?
O    ==       N    strict-equal?
O    =?       N    same?
O    >        N    greater?
O    >=       N    greater-or-equal?
....
==== evaluation and binding
....
N    all
N    any
N    apply
N    bind
N    context?
N    do
N    get
N    in
A    index?
F    quote
N    set
N    unset
N    value?
....
==== numerical and logical computation
....
A    absolute
O    +           A    add
O    and         A    and~
F    acos        N    arccosine
F    asin        N    arcsine
F    atan        N    arctangent
F    atan2       N    arctangent2
N    checksum
A    complement
F    cos         N    cosine
O    /           A    divide
A    even?
N    exp
N    log-10
N    log-2
N    log-e
N    max
F    mod
O    //          F    modulo
O    *           A    multiply
N    min
N    NaN?
A    negate
N    negative?
N    not
A    odd?
O    or          A    or~
N    positive?
O    **          A    power
A    random
O    %           A    remainder
A    round
O    <<          R    shift-left       N shift/left
O    >>          R    shift-right      N shift
O    >>>         R    shift-logical    N shift/logical
N    shift
N    sign?
F    sin         N    sine
F    sqrt        N    square-root
O    -           A    subtract
F    tan         N    tangent
O    xor         A    xor~
N    zero?
....
==== series manipulation
....
F    alter
A    append
A    at
A    back
A    change
A    clear
A    copy
F    empty?
F    extract
F    fifth
A    find
F    first
F    fourth
A    head
A    head?
A    index?
A    insert
F    last
A    length?
A    move
A    next
F    offset?
F    pad
A    pick
A    poke
A    put
A    random
F    rejoin
A    remove
F    repend
F    replace
A    reverse
F    second
A    select
A    sort
A    skip
F    split
A    swap
A    tail
A    tail?
A    take
F    third
A    trim
....
==== control
....
F    also
N    break
N    case
F    comment
N    continue
N    either
N    exit
N    forall
N    foreach
N    forever
F    halt
N    if
N    loop
F    q
F    quit
R    quit-return
N    remove-each
N    repeat
N    return
N    switch
N    unless
N    until
N    while
....
==== input/output
....
R    ask
R    browse
F    cd
F    change-dir
F    clean-path
A    close
A    create
R    create-dir
A    delete
F    dir
F    dir?
F    dirize
R    exists?
A    form
R    get-current-dir
F    input
F    list-dir
F    ll
F    load
F    ls
F    make-dir
A    modify
A    mold
N    new-line
N    new-line?
F    normalize-dir
A    open
A    open?
N    prin
N    print
F    probe
F    pwd
A    query
A    read
R    read-clipboard
A    rename
F    save
R    set-current-dir
N    size?
F    split-path
F    suffix?
N    to-local-file
F    to-red-file
A    update
F    what-dir
A    write
R    write-clipboard
....
==== exception handling
....
F    attempt
N    catch
F    cause-error
N    throw
N    try
....
==== preprocessor
....
F    expand
F    expand-directives
....
==== parser
....
F    on-parse-event
N    parse
F    parse-trace
....
==== GUI system
....
F    center-face
F    clear-reactions
F    distance?
F    do-actor
F    do-events
F    do-file
F    draw
R    find-flag?
F    get-scroller
F    insert-event-func
F    layout
F    overlap?
F    remove-event-func
F    request-dir
F    request-file
F    request-font
F    set-focus
F    show
F    size-text
F    unview
F    view
F    within?
....
==== reactivity
....
O    is       F is~ (hidden)
F    react
F    react?
R    set-quiet
....
==== environment and OS-related
....
N    call
N    get-env
N    list-env
N    now
N    set-env
N    stats
N    wait
....
==== help facilities
....
F    ?
F    ??
F    about
F    help
F    source
F    what
....
== Errors list

The format in each sub-section is
....
type (code base)
    id -> string or block
    etc. 
....

=== Throw Errors
....
throw ( 0 )
    break -> "no loop to break"
    return -> "return or exit not in function"
    throw -> ["no catch for throw:" :arg1]
    continue -> "no loop to continue"
....
=== Notes
....
note ( 100 )
    no-load -> ["cannot load: " :arg1]
....
=== Syntax Errors
....
syntax ( 200 )
    invalid -> ["invalid" :arg1 "at" :arg2]
    missing -> ["missing" :arg1 "at" :arg2]
    no-header -> ["script is missing a Red header:" :arg1]
    no-rs-header -> ["script is missing a Red/System header:" :arg1]
    bad-header -> ["script header is not valid:" :arg1]
    malconstruct -> ["invalid construction spec:" :arg1]
    bad-char -> ["invalid character in:" :arg1]
....
=== Script Errors
....
script ( 300 )
    no-value -> [:arg1 "has no value"]
    need-value -> [:arg1 "needs a value"]
    not-defined -> [:arg1 "word is not bound to a context"]
    not-in-context -> [:arg1 "is not in the specified context"]
    no-arg -> [:arg1 "is missing its" :arg2 "argument"]
    expect-arg -> [:arg1 "does not allow" :arg2 "for its" :arg3 "argument"]
    expect-val -> ["expected" :arg1 "not" :arg2]
    expect-type -> [:arg1 :arg2 "field must be of type" :arg3]
    cannot-use -> ["cannot use" :arg1 "on" :arg2 "value"]
    invalid-arg -> ["invalid argument:" :arg1]
    invalid-type -> [:arg1 "type is not allowed here"]
    invalid-type-spec -> ["invalid type specifier:" :arg1]
    invalid-op -> ["invalid operator:" :arg1]
    no-op-arg -> [:arg1 "operator is missing an argument"]
    bad-op-spec -> {making an op! requires a function with only 2 arguments}
    invalid-data -> ["data not in correct format:" :arg1]
    invalid-part -> ["invalid /part count:" :arg1]
    not-same-type -> "values must be of the same type"
    not-same-class -> ["cannot coerce" :arg1 "to" :arg2]
    not-related -> ["incompatible argument for" :arg1 "of" :arg2]
    bad-func-def -> ["invalid function definition:" :arg1]
    bad-func-arg -> ["function argument" :arg1 "is not valid"]
    bad-func-extern -> ["invalid /extern value:" :arg1]
    no-refine -> [:arg1 "has no refinement called" :arg2]
    bad-refines -> "incompatible or invalid refinements"
    bad-refine -> ["incompatible refinement:" :arg1]
    word-first -> ["path must start with a word:" :arg1]
    empty-path -> "cannot evaluate an empty path value"
    invalid-path -> ["cannot access" :arg2 "in path" :arg1]
    invalid-path-set -> ["unsupported type in" :arg1 "set-path"]
    invalid-path-get -> ["unsupported type in" :arg1 "get-path"]
    bad-path-type -> ["path" :arg1 "is not valid for" :arg2 "type"]
    bad-path-set -> ["cannot set" :arg2 "in path" :arg1]
    bad-field-set -> ["cannot set" :arg1 "field to" :arg2 "datatype"]
    dup-vars -> ["duplicate variable specified:" :arg1]
    past-end -> "out of range or past end"
    missing-arg -> "missing a required argument or refinement"
    out-of-range -> ["value out of range:" :arg1]
    invalid-chars -> "contains invalid characters"
    invalid-compare -> ["cannot compare" :arg1 "with" :arg2]
    wrong-type -> ["datatype assertion failed for:" :arg1]
    invalid-refine-arg -> ["invalid" :arg1 "argument:" :arg2]
    type-limit -> [:arg1 "overflow/underflow"]
    size-limit -> ["maximum limit reached:" :arg1]
    no-return -> "block did not return a value"
    throw-usage -> "invalid use of a thrown error value"
    locked-word -> ["protected word - cannot modify:" :arg1]
    bad-bad -> [:arg1 "error:" :arg2]
    bad-make-arg -> ["cannot MAKE" :arg1 "from:" :arg2]
    bad-to-arg -> ["cannot MAKE/TO" :arg1 "from:" :arg2]
    invalid-spec-field -> ["invalid" :arg1 "field in spec block"]
    missing-spec-field -> [:arg1 "not found in spec block"]
    move-bad -> ["Cannot MOVE elements from" :arg1 "to" :arg2]
    too-long -> "Content too long"
    invalid-char -> ["Invalid char! value:" :arg1]
    parse-rule -> ["PARSE - invalid rule or usage of rule:" :arg1]
    parse-end -> ["PARSE - unexpected end of rule after:" :arg1]
    parse-invalid-ref -> ["PARSE - get-word refers to a different series!" :arg1]
    parse-block -> ["PARSE - input must be of any-block! type:" :arg1]
    parse-unsupported -> {PARSE - matching by datatype not supported for any-string! input}
    parse-infinite -> ["PARSE - infinite recursion at rule: [" :arg1 "]"]
    parse-stack -> "PARSE - stack limit reached"
    parse-keep -> "PARSE - KEEP is used without a wrapping COLLECT"
    parse-into-bad -> {PARSE - COLLECT INTO/AFTER expects a series! argument}
    invalid-draw -> ["invalid Draw dialect input at:" :arg1]
    invalid-data-facet -> ["invalid DATA facet content" :arg1]
    face-type -> ["VIEW - invalid face type:" :arg1]
    not-window -> "VIEW - expected a window root face"
    bad-window -> {VIEW - a window face cannot be nested in another window}
    not-linked -> "VIEW - face not linked to a window"
    not-event-type -> ["VIEW - not a valid event type" :arg1]
    invalid-facet-type -> ["VIEW - invalid rate value:" :arg1]
    vid-invalid-syntax -> ["VID - invalid syntax at:" :arg1]
    react-bad-func -> {REACT - /LINK option requires a function! as argument}
    react-not-enough -> {REACT - reactive functions must accept at least 2 arguments}
    react-no-match -> {REACT - objects block length must match reaction function arg count}
    react-bad-obj -> "REACT - target can only contain object values"
    react-gctx -> ["REACT - word" :arg1 "is not a reactor's field"]
    lib-invalid-arg -> ["LIBRED - invalid argument for" :arg1]
....
=== Math Errors
....
math ( 400 )
    zero-divide -> "attempt to divide by zero"
    overflow -> "math or number overflow"
    positive -> "positive number required"
....
=== Access Errors
....
access ( 500 )
    cannot-open -> ["cannot open:" :arg1]
    invalid-utf8 -> ["invalid UTF-8 encoding:" :arg1]
    no-connect -> ["cannot connect:" :arg1 "reason: timeout"]
....
=== User Errors
....
user ( 800 )
    message -> [:arg1]
....
=== Internal Errors
....
internal ( 900 )
    bad-path -> ["bad path:" arg1]
    not-here -> [arg1 "not supported on your system"]
    no-memory -> "not enough memory"
    wrong-mem -> "failed to release memory"
    stack-overflow -> "stack overflow"
    too-deep -> "block or paren series is too deep to display"
    feature-na -> "feature not available"
    not-done -> "reserved for future use (or not yet implemented)"
    invalid-error -> "error object or fields were not valid"
    routines -> {routines require compilation, from OS shell: `red -c <script.red>`}
    red-system -> {contains Red/System code which requires compilation}
....

== Metadata for the toolchain

It is recommended to organize the metadata as `<word>: <value>` pairs. This
will facilitate storage and retrieval of these data by the toolchain as well
as the user. Certain elements of metadata, that are used by the toolchain,
*must* be in this format: `Needs:` and `Config:`, with prescribed types for
the `<value>` as indicated.

The following is a list of suggested and compulsory elements.

....
element     type           description

Title:      string!        application title
Purpose:    string!        short description of the application purpose
Author:     string!        source code author name
File:       file!          name of the source file
Version:    tuple!         source code version
Date:       date!          date of last version
Rights:     string!        copyrights
License:    [url! string!] source license (URL or full text)
History:    block!         source modifications history
Note(s):    string!        any special notice

Language:   word!          language of the comments
Tabs:       integer!       number of spaces between tab positions
Icon:       file!          *.ico file with icon for executable

Needs:      [word! block!] module(s) that is/are to be included
Config:     ???
....

== Additional documentation

The following is a list of official documents that complement the information given in this one.

. https://github.com/red/red/blob/master/README.md[README file for the toolchain]
. http://static.red-lang.org/red-system-specs-light.html[Red/System Language Specification]
. https://doc.red-lang.org/en/[Red Programming Language Documentation] notably:
  .. https://doc.red-lang.org/en/map.html[map! datatype]
  .. https://doc.red-lang.org/en/gui.html[GUI System]
  .. https://doc.red-lang.org/en/reactivity.html[Reactive Programming]
  .. https://doc.red-lang.org/en/preprocessor.html[Preprocessor]
. https://github.com/red/red/blob/master/docs/conversion-matrix.xlsx[Conversion matrix]
. http://www.red-lang.org/2013/11/041-introducing-parse.html[Introducing Parse] (blog article from 2013)

== Glossary
....
                                        section

action                                  4.2.6
  inherited action                      4.2.6
active type                             4.2.5
application of a function               3.3
arity of a function                     3.3
atomic type                             4.2.3
backspace (U+0008)                      5.2.6
base64 character                        5.2.12
binding                                 2.4, 3.3, 6.3
bitset spec dialect                     2.5, 5.3.5
bound word                              2.4
built-in constant                       2.4
built-in function                       2.4
built-in type                           2.4
built-in typeset                        4.3
caret (U+005E)                          5.2.6
catch                                   12.2.3
character
  backspace (U+0008)                    5.2.6
  base64 character                      5.2.12
  caret (U+005E)                        5.2.6
  control character                     5.2.5, 5.2.6
  delete (U+007F)                       5.2.6
  double quote (U+0022)                 5.2.6
  escape (U+001B)                       5.2.6
  escaped character                     5.2.6, 5.2.8, 5.2.9, 5.2.10
  form feed (U+000C)                    5.2.6
  hexadecimal codepoint                 5.2.6
  horizontal tab (U+0009)               3.1, 5.2.6
  line feed ( U+000A)                   3.1, 5.2.6
  new-line character                    5.2.7
  next line (U+0085)                    3.1, 5.2.7
  non-breaking space (U+00A0)           3.1
  null (U+0000)                         5.2.6
  semicolon                             3.1
  space (U+0020)                        3.1
  tab (U+0009)                          3.1, 5.2.6
  Unicode Code Point                    3.1
  whitespece character                  3.1
class (of object)                       5.3.6
color (RGB)                             5.2.4, 5.3.4
comment                                 3.1
compilation                             2.2
compiler                                2.2
compose dialect                         2.5, 7.5
composite type                          4.2.3
console                                 2.2
context                                 2.4, 6.2
  global context                        2.4, 6.2
control character                       5.2.5, 5.2.6
decaying type                           4.2.5
delete character (U+007F)               5.2.6
dialect                                 2.5
  bitset spec dialect                   2.5, 5.3.5
  compose dialect                       2.5, 7.5
  draw dialect                          2.5, 13.3
  error spec dialect                    2.5, 5.3.7
  function spec dialect                 2.5, 5.3.8
  image spec dialect                    2.5, 5.3.4
  map spec dialect                      2.5, 5.3.11
  object spec dialect                   2.5, 5.3.6
  parse dialect                         2.5, 13.2
  preprocessor dialect                  2.5, 13.1
  routine spec dialect                  2.5, 5.3.9
  shape dialect                         2.5, 13.3
  system dialect                        2.5, 17
  vector spec dialect                   2.5. 5.3.3
  Visual Interface dialect (VID)        2.5, 13.3
direct type                             4.2.2
docstring                               5.3.8, 5.3.9
Domain Specific Language (DSL)          2.5
double quote (U+0022)                   5.2.6
draw dialect                            2.5, 13.3
DSL (Domain Specific Language)          2.5
end-of-line comment                     3.1, 3.2
error spec dialect                      2.5, 5.3.7
escape (U+001B)                         5.2.6
escaped character                       5.2.6, 5.2.8, 5.2.9, 5.2.10
evaluation                              7
  shortcut evaluation                   7.5
execution                               2.2
  of a block                            7.1, 7.5
expression                              3.3
  infix expression                      3.3
form feed (U+000C)                      5.2.6
free-form text                          3.1
function
  application                           3.3
  infix function                        3.3
  prefix function                       3.3
function spec dialect                   2.5, 5.3.8
function type                           4.2.2
global context                          2.4, 6.2
graphical user interface (GUI)          13.3
grouped value                           3.1
grouping token                          3.1
GUI (graphical user interface)          13.3
hexadecimal codepoint                   5.2.6
homoiconic                              2.3
horizontal tab (U+0009)                 3.1, 5.2.6
host computer                           2.2
IEEE 754 binary64 format                5.2.2
image spec dialect                      2.5, 5.3.4
image color/transparency                5.3.4
indentation                             3.1
indirect type                           4.2.2
infix expression                        3.3
inherited action                        4.2.6
interactive console                     2.2
interpretation                          2.2
ipv4                                    5.2.4
left associative operator               3.3
lexeme                                  3.1
lexical analysis                        3.1
line feed ( U+000A)                     3.1, 5.2.6
map spec dialect                        2.5, 5.3.11
metadata                                3.1, 16
new-line character                      5.2.7
next line (U+0085)                      3.1, 5.2.7
non-breaking space                      3.1
null (U+0000)                           5.2.6
object class                            5.3.6
object spec dialect                     2.5, 5.3.6
operator                                3.3
parent type                             4.2.6
parse dialect                           2.5, 13.2
passive type                            4.2.5
polymorphic function - see action
pre-defined word                        2.4
precedence rules                        3.3
prefix function                         3.3
preprocessor dialect                    2.5, 13.1
prologue                                3.1
reactivity                              13.4
Read Evaluate Print Loop (REPL)         2.2
Red toolchain                           2.2
Red/System (dialect)                    2.5, 17
REPL (Read Evaluate Print Loop)         2.2
RGB color scheme                        5.2.4, 5.3.4, 14.1
RGBA color/transparency scheme          5.3.4
routine spec dialect                    2.5
shape dialect                           2.5, 13.3
shortcut evaluation                     7.5
single value                            3.1
space (U+0020)                          3.1
syntactic analysis                      3.1
system dialect                          2.5, 17
tab (U+0009)                            3.1, 5.2.6
target computer                         2.2
throw                                   12.2.3
toolchain                               2.2
transparency (of image)                 5.3.4
type                                    2.3, 4
  active type                           4.2.5
  atomic type                           4.2.3
  composite type                        4.2.3
  decaying type                         4.2.5
  direct type                           4.2.2
  function type                         4.2.2
  indirect type                         4.2.2
  parent type                           4.2.6
  passive type                          4.2.5
  type hierarchy                        4.3
Unicode Code Point                      3.1
UTF-8 scheme                            3.1, 5.4.3, 5.4.7, 5.4.10, 11.1, 11.5
value                                   2.3, 5
  grouped value                         3.1
  single value                          3.1
  value casting                         5.5
  value conversion                      5.4
  value creation                        5.3
vector spec dialect                     2.5, 5.3.3
Visual Interface) dialect (VID)         2.5, 13.3
whitespace                              3.1
word                                    2.4, 6.1
....

== List of outstanding issues
....
issue  spec section

1262   8.1
1263   8.4
1267   8.1, 8.4
1956   8.4
1957   5.7
1960   5.6.3
1961   9.3
2216   8.1
2492   3.1
2521   9.3
2527   5.7
2523   5.6.3
2554   5.6.2
2565   4.3
2577   5.3.11
2578   7.3.5
2589   5.3.8
2596   5.3.3
2609   5.3.5
2618   5.7
2622   7.4.1
2625   5.6.2
2628   12.1.1
2633   5.8.1, 12.1
2640   5.3
2642   5.3.9
2645   5.4.2
2650   5.8.1
2657   5.8.1
2658   5.8.1
2661   5.8.1
2662   5.8.2
2663   5.8.2
2668   11.1
2686   11.1
2776   8.1
....
