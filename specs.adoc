= Red Language Specification - draft
:imagesdir: /images
:toc:
:numbered:

== Introduction

The purpose of this document is to codify the lexical/syntactic and semantic rules
of the Red programming language, and thus to be the authoritative document for: 

* verifying implementation conformity
* tracking changes in the language design, including why changes were made
* acting as a reference for tests

In as much as feasible, and in order to avoid duplication, existing pieces
of official documentation will be referred to. A list of those can be found in
section 15.

== Conventions

In this document, technical terms -- whether in general use or specific to the Red
language -- will be written in _italics_ when first used and sometimes also on
some subsequent occasions. Values from the Red language, grammatical categories,
rule numbers and Unicode Code Point numbers will be written in `monospace font`.

Rules have a code in the form: `Letter + 3 digits`. The number is an incremental counter.
The prefix letter can be:

* **`S`**: for lexical and syntactic rules.
* **`E`**: for evaluation rules.

== Overview

=== Characterization

Red is a next-generation programming language strongly inspired by Rebol,
but with a broader field of usage thanks to its native-code compiler,
from system programming to high-level scripting and cross-platform reactive GUI,
while providing modern support for concurrency.

_**The concurrency part is far from being implemented, mention it here?**_

=== Red toolchain

A program written in Red is intended to be executed on a _target computer_.
To that end, it will be submitted to the _Red toolchain_ which is a program
executing on a _host computer_; this computer may be, but need not be
identical to the target computer. In case the two are identical,
the program execution may take the form of _interpretation_, i.e. the effect
of the program is the result of the toolchain's operation itself.
In either case, the execution may occur through _compilation_, i.e. the toolchain
produces a program in a lower-level language (e.g. machine code) suitable
for execution on the target computer. The toolchain is constructed such that
the effect of the program is the same whether it is executed through
interpretation or compilation. A further facility of the toolchain is
that it provides one or more _interactive consoles_, i.e. visual interfaces
which accept program fragments and display the result of evaluating them
(REPL or Read Evaluate Print Loop).

Information about the installation and usage of the toolchain can be found
in the README file of the https://github.com/red/red[Red repository on Github].
This repository contains the full source code of the toolchain, which may be
said to be the final authority on what the Red language is.

=== Values and types

An important property of Red is that any Red program is an _ordered sequence
of Red values_, i.e. code and data are a priori indistinguishable.
In other words, Red is _homoiconic_. Thus, interpretation of a Red program
is tantamount to evaluating each of its constituent values in turn,
according to the evaluation rules. Each Red _value_ has a _type_ and the types
themselves are also values of the language. The type of each value can be
determined either _lexically_ (_single values_), or _syntactically_ (_grouped
values_).

=== Words, contexts and binding

A special category of values is formed by _words_, that play
a similar role to identifiers and keywords of other languages.
Red does *not* have identifiers nor keywords: as will be explained in more
detail below, any _word_ may _refer_ to a value in some _context_.
We say that the word is _bound to_, or _in_ the context.
Initially, some words refer to certain values in the _global context_,
notably to _built-in functions_, _types_ (type names conventionally end in `!`)
and _constants_ such as the truth values: `true` and `false`, as well as `none`
("nil" or "null" in other languages). Evaluation of a word yields the value
it refers to. The evaluation rules given below will state,
amongst others, how words can come to refer to values in the course of
program execution.

=== Dialects

Red makes available a large number of different value types. The evaluation
rules stated below describe the interpretation of these values when they
occur in a Red _program_ which, as stated before, is nothing more or less
than a sequence of values.
The users may furthermore use and interpret Red values, when considered as _data_,
in ways of their own, and thus create _dialects_ or _Domain Specific Languages
(DSLs_).

In fact, Red itself contains
a number of dialects where blocks of data are interpreted in a specific way:
the _system dialect_ (Red/System, see next paragraph), the _parse dialect_,
the _visual interface dialect (VID)_, which also uses the _draw dialect_,
the various _spec dialects_ involved in defining functions, objects, bitsets,
vectors and more.

Red/System is on the one hand a language of its own: programs written in Red/System
can be compiled and executed using the toolchain. As a dialect of Red its purpose
is to provide low-level system programming capabilities, and it serves both as
a tool to build Red's runtime library and as intermediate language for the
compiler to generate machine code from.

The standard interpretation of Red values might be called the _do dialect_,
since the built-in function `do`, when supplied with an argument which is a
sequence of Red values, will evaluate them according to the evaluation rules
given here (cf. the Lisp function `eval`).

== Types

=== Type list
 
The full list of types of the languages is given below, with an explanation of the usage of their values.

....
type            usage of values

datatype!       types of the language (first class values)
typeset!        sets of types
none!           single value: none, i.e. a value belonging to none of the other types
logic!          true or false
char!           character (Unicode Code Point)
integer!        integer numbers 
float!          floating point numbers
percent!        id. expressed as a percentage
time!           time interval or point in time
pair!           2-dimensional coordinates or size 
tuple!          color in RGB or other scheme, IPv4 adres
word!           identifier that can be bound
lit-word!       quoted (unevaluated) word
set-word!       word to be bound
get-word!       word to be evaluated
refinement!     optional argument of function
issue!          identifier that cannot be bound
block!          ordered collection of values of any type (polymorphic array),
                may also be used as unordered collection (set)
hash!           block with quick access
paren!          differs from block in behaviour under evaluation  
path!           specifying optional arguments in function calls,
                selection of components of composite values
lit-path!       quoted (unevaluated) path
set-path!       setting a component of a composite value
get-path!       path to be evaluated
vector!         ordered sequences of values of identical type, which can be
                char! or integer! (8/16/32 bits), percent! or float! (32/64 bits);
                default: 32 bits for char! or integer! and 64 bits otherwise
string!         ordered sequence of characters (Unicode Code Points)
file!           file or directory (folder)
url!            URL
tag!            tag in the sense of HTML, XML etc.
email!          email-address
binary!         ordered sequence of bytes
image!          2-dimensional array of pixels (RGBA values encoded in 4 bytes each)) 
bitset!         ordered sequence of values true or false
map!            collection of pairs of values where the first value in each pair functions
                as key for retrieval of the second; keys are restricted to types
                any-word!, any-string!, number!, char!, pair!, tuple!
object!         collection of word-value pairs, i.e. a context in which the words
                are bound, and refer to the corresponding values; objects are
                capable of triggering asynchronous events in response to changes
                in their components, thus enabling reactive programming
error!          specialized objects representing error conditions
native!         pre-defined functions with built-in evaluation according to special rules
action!         pre-defined polymorphic functions of one or two arguments with built-in evaluation
op!             operators, i.e. pre-defined infix functions of two arguments
function!       user-defined functions
routine!        user-defined functions with body in Red/System code
unset!          single value indicating the absence of a usable value
event!          representation of external activity   
handle!         opaque integer for communication with operating system
....

=== Type categories

As seen in the previous section, Red has a rather large number of different types.
For a better understanding of their nature and that
of their values, it is useful to make a number of distinctions into different categories.

* textual representation: types having lexically/syntactically representable values or not
* internal storage: _direct types_ vs _indirect types_ and _function types_
* internal structure of values: _atomic types_ vs _composite types_
* reflectivity: types with values that admit _reflection_  or not
* evaluation: _passive types_, _decaying types_, _active types_, _function types_
* implementation of built-in functions: _parent types_

==== Types according to their textual representation

This distinction has been treated in section 5.1.

==== Direct/Indirect/Function types

Red values are internally stored using _value slots_ of uniform size. Values of _direct types_
fit completely into one such slot; for values of _indirect types_, which have a variable number
of components, the slot stores a _pointer_ to a further storage area that holds the components
of the value. As a consequence, when a word ("variable") is made to refer to a value of indirect
type or such a value is supplied as argument to a function, the components of this value may
be changed through operations on the variable or the function argument.
In order to prevent this, values of indirect types must be explicitly copied before being
transmitted as argument or having a word refer to them. A third category to be distinguished
is that of _function types_, where pointers to the argument list and the body are stored in the slot.

==== Atomic/Composite types

Values of certain types have _components_ which may be extracted and/or changed using a variety of
facilities which will be specified below under evaluation. Such types are called _composite_ 
and the others are _atomic_. All indirect types are composite, but the converse is not true:
function types are composite. as well as some direct types. Note that component selection
in values of direct types cannot be used to change the component, only to extract it.
Binding such a component to a value results in a new instance of the direct value being created,
having the changed component.

==== Types that admit reflection

Values of some types have (internal) properties of interest to the user which may usefully be exposed.
E.g. the set of words from the word/value pairs making up an object may be retrieved by the built-in
function `words-of`. Likewise, the argument spec of a function may be retrieved by `spec-of`.

_** We should perhaps consider `context?` or rather `context-of` as a reflector also**_

==== Types according to the evaluation of their values

* Values of _passive types_ evaluate to themselves. The great majority of types belong to this category.
* Values of _decaying types_ are quoted instances of other values. They evaluate to the unquoted value.
* Values of _active types_ are bound to a context, their binding can be retrieved to yield the value referred to.
* Values of _function types_, when evaluated, result in the application of the function to its arguments.

Detailed rules for the evaluation in these various cases are given in section. 

==== Parent types

The notion of _parent type_ arises in the implementation of _actions_, i.e. pre-defined polymorphic
functions of up to two arguments with built-in evaluation, e.g. `add`, `subtract`, `copy`, `find`, etc.
The implementation uses a _dispatch table_ which contains a pointer to a specific run-time
function for each allowed combination of action and type of first argument. These functions
are grouped by the type to which they apply. Now for any action/type combination,
such function may be designated as _inherited_ from the parent type, and in this way
two or more types may share the same implementation for that action.

_**Mention pseudo types `symbol`, `series!` and `context!`?**_ 

==== Overview table

....
type     value representation  direct (D)/      atomic (A)/   reflection     passive (P/        parent type
            lexical (L)/       indirect (I)/    composite (C)    (R)         decaying (D)/
            syntactic (S)/     function (F)     values                       active (A)/
            using make (M)/      storage                                     function (F)
            using words (W)                                                  evaluation
                                                                   
datatype!         W                 D                A                            P   
typeset!          M                 D                A                            P   
none!             W                 D                A                            P
logic!            W                 D                A                            P
char!             L                 D                A                            P              integer!
integer!          L                 D                A                            P
float!            L                 D                A                            P
percent!          L                 D                A                            P              float!
time!             L                 D                C                            P              float!
pair!             L                 D                C                            P
tuple!            L                 D                C                            P
word!             L                 D                A                            A
lit-word!         L                 D                A                            D               word!
set-word!         L                 D                A                            A               word!
get-word!         L                 D                A                            A               word!
refinement!       L                 D                A                            P               word!
issue!            L                 D                A                            P               word!
block!            S                 I                C                            P
hash!             M                 I                C                            P               block!
paren!            S                 I                C                            A               block!
path!             L                 I                C                           A+F              block!
lit-path!         L                 I                C                            D               path!
set-path!         L                 I                C                            A               path!
get-path!         L                 I                C                            A               path!
vector!           M                 I                C                            P               string!
string!           L                 I                C                            P
file!             L                 I                C                            P               url!
url!              L                 I                C                            P               string!
tag!              L                 I                C                            P               string!
email!            L                 I                C                            P               string!
binary!           L                 I                C                            P               string!
image!            M                 I                C                            P
bitset!           M                 I                C                            P
map!              S                 I                C             R              P
object!           M                 I                C             R              P
error!            M                 I                C             R              P               object!
native!           W                 F                A             R              F
action!           W                 F                A             R              F               native!
op!               W                 F                A             R              F               native!
function!         M                 F                A             R              F
routine!          M                 F                A             R              F               function!
unset!            M                 D                A                            P
event!            W                 D                C                            P
handle!           W                 D                A                            P               integer!
....
=== Type hierarchy

For the convenience of the user, certain typesets have been pre-defined
which group related types. These will notably be used for indicating
the allowed types of arguments to polymorphic functions. E.g. `add` takes
two arguments whose types are in the typeset `number!`.

....
any-type!              
|--default!              
|  |--immediate!         
|  |  |--datatype!        
|  |  |--typeset!         
|  |  |--none!            
|  |  |--logic!           
|  |  |--scalar!          
|  |  |  |--char!          
|  |  |  |--number!        
|  |  |  |  |--integer!     
|  |  |  |  |--any-float!   
|  |  |  |     |--float!     
|  |  |  |     |--percent!   
|  |  |  |--time!          
|  |  |  |--pair!          
|  |  |  |--tuple!         
|  |  |--any-word!        
|  |     |--word!          
|  |     |--lit-word!      
|  |     |--set-word!      
|  |     |--get-word!      
|  |     |--refinement!    
|  |     |--issue!         
|  |--series!            
|  |  |--any-block!       
|  |  |  |--any-list!      
|  |  |  |  |--block!       
|  |  |  |  |--hash!        
|  |  |  |  |--paren!       
|  |  |  |--any-path!      
|  |  |     |--path!        
|  |  |     |--lit-path!    
|  |  |     |--set-path!    
|  |  |     |--get-path!    
|  |  |--vector!          
|  |  |--any-string!      
|  |  |  |--string!        
|  |  |  |--file!          
|  |  |  |--url!           
|  |  |  |--tag!           
|  |  |  |--email!         
|  |  |--binary!          
|  |  |--image!           
|  |--bitset!            
|  |--map!               
|  |--any-object!        
|  |  |--object!          
|  |  |--error!           
|  |--any-function!      
|     |--native!          
|     |--action!          
|     |--op!              
|     |--function!        
|     |--routine!         
|--internal!            
   |--unset!             
   |--event!             
   |--handle!            
....

== Lexical  and syntactic rules

For submission to the Red toolchain, a Red program must be prepared as a text file.
This may contain any _Unicode Code Points_, encoded using the _UTF-8 scheme_. 

As a first operation of the toolchain, the text file will be subjected to lexical analysis
which will break the text up in a series of _lexemes_, i.e. textual representations of Red
_single values_, interspersed with _grouping tokens_. The grouping tokens should occur in
properly nested pairs, and are the following: `( ), [ ], #( ), #[ ]`. A sequence of lexemes
enclosed in matching grouping tokens represents a Red _grouped value_ of a certain type,
and this construct may again be enclosed in grouping tokens etc. 

As a rule, lexemes must be separated from each other and from grouping tokens by
one or more _whitespace characters_. In the Red source text, whitespace characters are
space (`U+0020`), tab (`U+0009`), line feed (`U+000A`), next line (`U+0085`)
and non-breaking space (`U+00A0`).

_**This is most certainly short of some whitespace values, please correct See also issue #2492**_

In certain cases, where there can be no ambiguity, the requirement for whitespace between values
can be relaxed. For example, it is possible to omit whitespace between two consecutive block!
values and between word! values and block! values. These two examples are both syntatically valid:

     equal?[1234][1234]
     equal?           [1234]         [1234]

A well-formed Red program begins with a _prologue_ which may contain _metadata_ for the toolchain
and/or the reader. The relevant data will be described _**at the appropriate point**_.

A formal grammar corresponding to the above presentation is given below. As usual,
`*` means zero or more instances. The comment to any production rule, which starts after the `;` on the line,
states the type of the single or grouped values generated by this rule. Any non-terminal that is not
further defined in the grammar is explained in the individual sections thereafter.

**`S100`**:: program structure

    <program>  ::= <prologue> <value>*
    <prologue> ::= Red [ <value>* ]
    <value>    ::= <lexeme> | <group>
    <lexeme>   ::= <integer>            ; integer!
             | <float>                  ; float!
             | <integer>% | <float>%    ; percent!
             | <integer>x<integer>      ; pair!
             | <time>                   ; time!
             | <tuple>                  ; tuple!
             | <word>                   ; word!
             | '<word>                  ; lit-word!
             | <word>:                  ; set-word!
             | :<word>                  ; get-word!
             | /<word>                  ; refinement!
             | #<word>                  ; issue!
             | <char>                   ; char!
             | <string>                 ; string!
             | <file>                   ; file!
             | <url>                    ; url!
             | <email>                  ; email!
             | <tag>                    ; tag!
             | <binary>                 ; binary!
             | <path>                   ; path!
             | '<path>                  ; lit-path!
             | <path>:                  ; set-path!
             | :<path>                  ; get-path!
    <group>    ::= <paren>
             | <block>
             | <map>
             | <constructor>
    <paren> ::=    ( <value>* )         ; paren!
    <block> ::=    [ <value>* ]         ; block!
    <map> ::=      #( <value>* )        ; map! even number of values only
    <constructor> ::= #[ <value>* ]     ; reserved for general typed value constructor
 
== Representation of values

=== Introduction

The types listed in rule S100 are the only ones that have lexically or syntactically determined values.
Values that are not lexically or syntactically determined may generally be represented in programs by
expressions of the form `make <type> <spec>`, where `<type>` is a type name and `<spec>`
is a value that is interpreted by the `make` function as appropriate for the given type.
For several types, the available values are referred to by words at program start: `none!` has `none`,
`logic!` has `true = yes = on` and `false = no = off`, and `datatype!` has all the valid
type names pre-defined; likewise `native!`, `action!` and `op!` have all the built-in functions
and operators pre-defined. Values of types `event!` and `handle!`, that are used to
communicate with operating system, can only be represented by words that are arguments to functions
handling this communication.

_**Mention general typed value constructor #[ <type> <value>* ]**_

The following sub-sections will specify the lexical structure resp. the <spec> argument of the `make`
function for values of each of the types as appropriate.

=== Lexical structure of values

==== `integer!`

**`S101`**::
An `integer!` value is written as a signed integer number from `-2^31^` to `2^31^-1`
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
_**Hexadecimal notation, eg FFh, is omitted as this is under discussion**_

Examples: `123`, `-123`, `+0001`, `1'000`

==== `float!`

**`S102`**::
A `float!` value is written as a signed floating point number in the range of the IEEE 754 binary64 format,
in decimal notation. Leading zeroes are allowed, as well as `'` signs for separation.
No zero is needed before the decimal point when the absolute value is smaller than `1.0`.
The number may be followed by `E` or `e` with a signed integer exponent on base 10.
Note that in this case, no decimal point is required.

Examples: `1.23`, `-0.5`, `.5`, `+010.20`, `1E9`

==== `time!`

**`S103`**::
....
    <time> ::= <hmsd> | +<hmsd> | -<hmsd>
    <hmsd> ::= <hours>:<minutes> | <hours>:<minutes>:<seconds> | <hours>:<minutes>:<seconds>.<decimals> |
               <minutes>:<seconds>.<decimals>
....

where `<hours> <minutes> <seconds>` and `<decimals>` may each be any unsigned `<integer>`
(leading zeroes are allowed, carry is performed as appropriate when the numbers are outside
the normal range `0..23` for hours, `0..59` for minutes and seconds).

Examples: `10:20`, `10:20:30.456`, `20:30.5`, `-1:00:00`

==== `tuple!`

**`S104`**::
A `tuple!` value is written as 3 to 12 `<integer>` values in the range `0..255` separated by dots `.`

Examples: `192.168.1.2`, `255.255.128` 

==== `word!`

**`S105`**::
A `word!` value is written as one or more characters from the entire Unicode range excluding control characters
(notably Unicode sets C0, C1), whitespace characters and the following set: `/ \ ^ , [ ] ( ) { } " # $ % @ : ;`.
A `word!` value does not begin with `0-9` or `'`.
Punctuation characters from the ASCII subset that *are* allowed in words are: `! & ' * + - . < = > ? _ `` `| ~`.
Words are _case-insensitive_, i.e. changing any letter in the word into the corresponding upper- or lower-case
variant does not create a different word.

Examples: `abc`, `Abc`, `ABC`, `+`, `<>`, `integer!`, `last-item?` ; the first three are the same `word!` value.

==== `char!`

**`S106`**::
....
    <char> :: = #"<single-character>"
    <single-character> ::= <viewable-character> | <escaped-character> | <hexadecimal-codepoint>
    <escaped-character> :: =  ^(null) | ^@ | ^(back) | ^(tab) | ^- | ^(line) | ^/ | ^(page) |
                          ^(esc) | ^" | ^^ |  ^(del) | ^~ | ^A | ^B | ... | ^Z | ^[ | ^\ | ^] | ^_
    <hexadecimal-codepoint> :: = ^(<hex>) | ^(<hex><hex>) | ^(<hex><hex><hex>) | ^(<hex><hex><hex><hex>)  
....
where `<hex>` is two hexadecimal digits `0-9 A-F a-f`, thus `00` - `FF`

A `char!` value must be a valid single Unicode code point, i.e. an integer in the range 0 to 10FFFFF (hexadecimal notation). 

A `<viewable character>` is, in most cases, simply a displayable character. For example, `e`, `Ã©`, `â‚¬` or `ðŸ˜€`.
When a displayable character requires two or more graphemes to display it, each grapheme requires a separate Red character.
For example, when `Ã©` is encoded in its two character decomposed form `e` (`U+0065`) followed by
the combining `Â´` (`U+0301`) they cannot be considered a single `char!` value.

The correspondence between the escaped characters and Unicode code points is given in the table below.

     Named Form   Short Form    Character           Codepoint
     #"^(null)    #"^@"         null                U+0000
     #"^(back)"   #"^H"         backspace           U+0008
     #"^(tab)"    #"^I" #"^-"   horizontal tab      U+0009
     #"^(line)"   #"^J" #"^/"   line feed           U+000A
     #"^(page)"   #"^L"         form feed           U+000C 
     #"^(esc)"    #"^["         escape              U+001B
     #"^(del)"    #"^~"         delete              U+007F
     #"^""                      " - double quote    U+0022
     #"^^"                      ^ - caret           U+005E
     #"^A" - #"^Z"              control characters  U+0001 - U+001A
     #"^[" #"^\" #"^]"          control characters  U+001B - U+001D
     #"^_"                      control character   U+001F
    
Note that code point `U+001E` cannot be represented by `#"^^"` as expected, since that is already taken for caret.
Note also that `^` will be ignored in front of any single character with which it does not form (the beginning of)
an `<escaped-character>` or `<hexadecimal-codepoint>`. Thus e.g. `^3` yields the same as `3`.

Examples: `#"A", #"^/", #"^(0A)"`

==== `string!`

**`S107`**::
....
     <string> ::= "<single-character>*" | {<single-character>*}
....

where `<single-character>` is defined in rule `S106`

When the `<string>` is delimited by `" "` it must not contain unescaped _new-line characters_
`U+000A`, `U+0085`, `U+2028` and `U+2029`. When the `<string>` is delimited by `{ }` it may contain
unescaped new-line characters and any `"` as well as nested `{ }` pairs, but any unpaired `}`
character that is part of the `<string`> must be escaped by preceding it with `^`. Within a `<string>`,
the same remark holds for `^` as noted above for a `<char>`. 

Examples: `"abc^/def", {abc` +
`def}`

==== `file!`

**`S108`**::

A `file!` value is written as `%` followed by one or more non whitespace characters, or by zero or more
characters enclosed in `"  "` in which case whitespace characters except line feed and next line may be
included. The interpretation of this value is operating system dependent, but escaped characters of the
form `%<hex>` are accepted and converted.

==== `url!`

**`S109`**::

A `url!` value is written as three or more non whitespace characters, of which at least one `:` which must not
be the first or last character. Escaped characters of the form `%<hex>` are accepted and converted.

==== `email!`

**`S110`**::

An `email!` value is written as two or more characters containing one `@` but not beginning with it.
Escaped characters of the form `%<hex>` are accepted and converted.

==== `tag!`

**`S111`**::

A `tag!` value is written as zero or more characters, not starting with `<`, `=` or `>`, enclosed in `< >`.
Characters `"` and `'` are allowed but must each be properly paired and nested.

==== `binary!`

**`S112`**::
....
    <binary> ::= 2#{<base2-byte>*} | #{<hex>*} | 16#{<hex>*} | 64#{<base64-char>*}
....

where `<base2-byte>` is a group of 8 digits `0` or `1`, `<hex>` is defined in rule `S106`
and `<base64-char>` is a single character from the set `A-Z a-z 0-9 + /`; the individual elements within
the `#{ }` brackets (`<base2-byte>`, `<hex>` or `<base64-char>`) may be separated from the
brackets and from each other by whitespace.

Examples: `2#{00000001 00000010 00000011}, \#{ 01 02 03 }, 64#{AQID}`

==== `path!`

**`S113`**::
....
    <path> ::= <word>/<selector> | <path>/<selector>
    <selector>::= <integer> | <word> | :<word> | <paren>
....

Examples: `list/1/2`, `system/view/screens/2`, `list/:i`, `list/(i)`, `copy/part`

=== Values to be constructed by the `make` function

==== `typeset!`

**`S114`**::

TBD

==== `hash!`

**`S115`**::

TBD

==== `vector!`

**`S116`**::

TBD

==== `image!`

**`S117`**::

TBD

==== `bitset!`

**`S118`**::

TBD

==== `object!`

**`S119`**::

TBD

==== `error!`

**`S120`**::

TBD

==== `function!`

**`S121`**::

TBD

==== `routine!`

**`S122`**::

TBD

==== `op!`

**`S123`**::

TBD

== Words, contexts and binding

Red uses _words_ (values of type `word!`) to access values in much the same
way that other languages use variables. However, in Red, words *do not*
"store" values. Rather, a word _refers to a value_ in some _context_. i.e.
evaluating the word in that context yields the value. We sy that the word

, or2_in_ the context. Since functions, 
ncluding built-in functions and operators, are also values in Red, the words
that refer to these values appear to work like keywords in other languages.

Thus all word values have two important properties in this regard: their
symbol, that is their spelling (disregarding case), and the context they are
bound to. Something words *do not* have is a restriction on what values they
can refer to. In Red, values are strongly typed, but words, when used like
variables or keywords, are not.

_**The removed paragraph duplicated what was said under direct/indirect types**_

=== Contexts

A _context_ in Red is a collection of word/value pairs. The words in
this collection are all different, and the values are the values the words
refer to. You can think of it like two columns, where the first is a list
of unique symbols and the second contains a matching value for each.

There is one _global context_ containing all words that have passed lexical
analysis as well as those that have been pre-defined in the toolchain, and
which refer to values such as built-in functions and constants. Words in the
global context that are not pre-defined, are considered "unset", which is a
special kind of value, distinct from `none`.

In addition to the global context, any number of contexts may exist during
program execution. Every _object_ (value of type `object!`) gives rise to a
context, containing the field-name/value pairs of the object. Every function 
(value of type `function!`) also gives rise to a context, which contains
the pairs of formal parameter name and actual argument value to be used by 
the body of the function when it is executed.

The user may access the context of a word reflectively through the built-in
function `context-of` _**(this is still called `context?` but there is interest
in changing its name)**_ which can be applied to any word and will yield the
context the word is bound to, in the form of an object or function
as the case may be. Asking for the global context yields the object
`system/words`.

=== Binding

Words are bound to contexts as a result of:

* lexical analysis
- notably when the program containing the words is submitted to the toolchain
- or when a string representing some values is submitted to the REPL
- or through application of the built-in `load` function
* applying the built-in `set` function
* evaluating a `set-word!` value
* evaluating a `make object! <spec>` construct
* applying a function to its arguments
* applying the built-in `bind` function




== Comparison

=== Equality

=== Strict equality

=== Sameness

=== Type ordering

=== Type comparisons


== Creation and conversion of values

=== Creation (make)

=== Conversion (to)

== Evaluation rules

`a -> b` will be used to signify evaluation relation, from value or type `a` to value or type `b`.

=== Passive types

**`E100`**:: For all values of `passive!` types: `value -> value`. This is called the **identity rule**.

=== Decaying types

**`E101`**:: `lit-word! -> word!`. Evaluating a `'word` value results in its `word` counterpart.

**`E102`**:: `lit-path! -> path!`. Evaluating a `'v0/v1/.../vn` value results in its `v0/v1/.../vn` counterpart.

=== Active types

==== word! type

==== get-word! type

==== set-word! type

==== paren! type

==== path! type

==== get-path! type

==== set-path! type

=== Function types

==== action! type

==== native! type

==== op! type

==== function! type

==== routine! type

==== Options and optional arguments

=== Reduction

=== Selective reduction


== Evaluation process

=== Loading stage

=== Evaluation loop


== Exceptions

=== Error exceptions

==== Creation

==== Propagation

==== Interception

=== User exceptions

==== Creation

==== Propagation

==== Interception

== Preprocessor

== Pre-defined words list

=== constants
....
  characters
    comma
    CR
    dbl-quote
    dot
    escape
    lf
    newline
    null
    slash
    sp
    space
    tab
  floating point numbers
    pi
  logic! values
    false
    no
    off
    on
    true
    yes
  none! value
    none
  strings
    crlf
    font-fixed
    font-sans-serif
    font-serif
    p-indent
    value
  tuples (RGB color values)
    aqua
    beige
    black
    blue
    brick
    brown
    coal
    coffee
    crimson
    cyan
    forest
    glass
    gold
    gray
    green
    ivory
    khaki
    leaf
    linen
    magenta
    maroon
    mint
    navy
    oldrab
    olive
    orange
    papaya
    pewter
    pink
    purple
    reblue
    rebolor
    Red
    sienna
    silver
    sky
    snow
    tanned
    teal
    transparent
    violet
    water
    wheat
    white
    yello
    yellow
....
=== datatypes
....
    action!
    binary!
    bitset!
    block!
    char!
    datatype!
    email!
    error!
    event!
    file!
    float!
    function!
    get-path!
    get-word!
    handle!
    hash!
    image!
    integer!
    issue!
    lit-path!
    lit-word!
    logic!
    map!
    native!
    none!
    object!
    op!
    pair!
    paren!
    path!
    percent!
    point!
    refinement!
    routine!
    set-path!
    set-word!
    string!
    tag!
    time!
    tuple!
    typeset!
    unset!
    url!
    vector!
    word!
....
=== typesets
....
    any-block!
    any-function!
    any-list!
    any-object!
    any-path!
    any-string!
    any-type!
    any-word!
    default!
    immediate!
    internal!
    number!
    scalar!
    series!
....
=== natives
....
  enquiry
    complement?
    context?
    new-line?
    type?
    value?
  making
    compose
    construct
    reduce
  conversion
    debase
    dehex
    enbase
    lowercase
    uppercase
    to-hex
    to-local-file
  control
    break
    case
    continue
    either
    exit
    forall
    foreach
    forever
    if
    loop
    remove-each
    repeat
    return
    switch
    unless
    until
    while
  short-cut evaluation
    all
    any
  function definition
    does
    func
    function
    has
  math
    arccosine
    arcsine
    arctangent
    arctangent2
    checksum
    cosine
    exp
    log-10
    log-2
    log-e
    max
    min
    NaN?
    negative?
    positive?
    shift
    sign?
    sine
    square-root
    tangent
    zero?
  comparison
    equal?
    greater-or-equal?
    greater?
    lesser-or-equal?
    lesser?
    not-equal?
    same?
    strict-equal?
  set-operations
    difference
    exclude
    intersect
    union
    unique
  evaluation and binding
    as
    as-pair
    bind
    do
    get
    in
    set
    unset
  error handling
    catch
    throw
    try
  environment and OS related
    call
    get-env
    list-env
    now
    prin
    print
    set-env
    stats
    wait
  miscellaneous
    extend
    new-line
    not
    parse
....
=== actions
....
  general
    make
    random
    reflect
    to
    form
    mold
    eval-path
    compare
  scalar
    absolute
    add
    divide
    multiply
    negate
    power
    remainder
    round
    subtract
    even?
    odd?
  bitwise
    and~
    complement
    or~
    xor~
  series
    append
    at
    back
    change
    clear
    copy
    find
    head
    head?
    index?
    insert
    length?
    move
    next
    pick
    poke
    put
    remove
    reverse
    select
    sort
    skip
    swap
    tail
    tail?
    take
    trim
  I/O
    create
    close
    delete
    modify
    open
    open?
    query
    read
    rename
    update
    write
....
=== operators
....
             related action! (A)/native! (N)/
                routine! (R)/function (F)
    %        A remainder 
    *        A multiply
    **       A power
    +        A add
    -        A subtract
    /        A divide
    //       F modulo
    <        N lesser?
    <<       R shift-left <- N shift/left
    <=       N lesser-or-equal?
    <>       N not-equal?
    =        N equal?
    ==       N strict-equal?
    =?       N same?
    >        N greater?
    >=       N greater-or-equal?
    >>       R shift-right <- N shift
    >>>      R shift-logical <- N shift/logical
    and      A and~
    is       F is~ (hidden)
    or       N or~
    xor      N xor~
....
=== functions
....
  help
    ?
    ??
    about
    help
    source
    what
  enquiry
    action?
    binary?
    bitset?
    block?
    char?
    datatype?
    email?
    error?
    file?
    float?
    function?
    get-path?
    get-word?
    handle?
    hash?
    image?
    integer?
    issue?
    lit-path?
    lit-word?
    logic?
    map?
    native?
    none?
    object?
    op?
    pair?
    paren?
    path?
    percent?
    refinement?
    routine?
    set-path?
    set-word?
    string?
    tag?
    time?
    tuple?
    typeset?
    unset?
    url?
    vector?
    word?
    any-block?
    any-function?
    any-list?
    any-object?
    any-path?
    any-string?
    any-word?
    immediate?
    number?
    scalar?
    series?
    body-of
    class-of
    keys-of
    spec-of
    values-of
    words-of
    dir?
    empty?
    face?
  making
    charset
    context
    object
    routine
  conversion
    hex-to-rgb
    to-binary
    to-bitset
    to-block
    to-char
    to-email
    to-file
    to-float
    to-get-path
    to-get-word
    to-hash
    to-image
    to-integer
    to-issue
    to-lit-path
    to-lit-word
    to-logic
    to-map
    to-none
    to-pair
    to-paren
    to-path
    to-percent
    to-red-file
    to-refinement
    to-set-path
    to-set-word
    to-string
    to-tag
    to-time
    to-tuple
    to-typeset
    to-unset
    to-url
    to-word
  series
    alter
    extract
    fifth
    first
    fourth
    last
    offset?
    pad
    rejoin
    repend
    replace
    second
    split
    third
  math
    acos
    asin
    atan
    atan2
    cos
    math
    mod
    modulo
    sin
    sqrt
    tan
  GUI
    center-face
    clear-reactions
    distance?
    do-actor
    do-events
    do-file
    draw
    get-scroller
    insert-event-func
    layout
    overlap?
    remove-event-func
    request-dir
    request-file
    request-font
    set-focus
    show
    size-text
    unview
    view
    within?
  I/O
    cd
    change-dir
    clean-path
    dir
    dirize
    input
    list-dir
    ll
    load
    ls
    make-dir
    normalize-dir
    prin-out
    print-out
    probe
    pwd
    red-complete-file
    red-complete-input
    red-complete-path
    save
    split-path
    suffix?
    what-dir
  control
    also
    comment
    halt
    q
    quit
  miscellaneous
    collect
    quote
  reactivity
    react
    react?
  pre-processing
    expand
    expand-directives
  error handling
    attempt
    cause-error
  debugging
    do-safe
    dump-face
    dump-reactions
    on-parse-event
    parse-trace
....
=== routines
....
  enquiry
    event?
  conversion
    as-color
    as-ipv4
    as-rgba
  bitwise operations
    shift-left
    shift-logical
    shift-right
  control
    quit-return
    set-quiet
  GUI
    find-flag?
  I/O
    ask
    browse
    create-dir
    exists?
    get-current-dir
    last-lf?
    read-clipboard
    set-current-dir
    write-clipboard
    write-stdout
....
== Errors list
....
throw ( 0 )
    break -> "no loop to break"
    return -> "return or exit not in function"
    throw -> ["no catch for throw:" :arg1]
    continue -> "no loop to continue"
note ( 100 )
    no-load -> ["cannot load: " :arg1]
syntax ( 200 )
    invalid -> ["invalid" :arg1 "at" :arg2]
    missing -> ["missing" :arg1 "at" :arg2]
    no-header -> ["script is missing a Red header:" :arg1]
    no-rs-header -> ["script is missing a Red/System header:" :arg1]
    bad-header -> ["script header is not valid:" :arg1]
    malconstruct -> ["invalid construction spec:" :arg1]
    bad-char -> ["invalid character in:" :arg1]
script ( 300 )
    no-value -> [:arg1 "has no value"]
    need-value -> [:arg1 "needs a value"]
    not-defined -> [:arg1 "word is not bound to a context"]
    not-in-context -> [:arg1 "is not in the specified context"]
    no-arg -> [:arg1 "is missing its" :arg2 "argument"]
    expect-arg -> [:arg1 "does not allow" :arg2 "for its" :arg3 "argument"]
    expect-val -> ["expected" :arg1 "not" :arg2]
    expect-type -> [:arg1 :arg2 "field must be of type" :arg3]
    cannot-use -> ["cannot use" :arg1 "on" :arg2 "value"]
    invalid-arg -> ["invalid argument:" :arg1]
    invalid-type -> [:arg1 "type is not allowed here"]
    invalid-type-spec -> ["invalid type specifier:" :arg1]
    invalid-op -> ["invalid operator:" :arg1]
    no-op-arg -> [:arg1 "operator is missing an argument"]
    bad-op-spec -> {making an op! requires a function with only 2 arguments}
    invalid-data -> ["data not in correct format:" :arg1]
    invalid-part -> ["invalid /part count:" :arg1]
    not-same-type -> "values must be of the same type"
    not-same-class -> ["cannot coerce" :arg1 "to" :arg2]
    not-related -> ["incompatible argument for" :arg1 "of" :arg2]
    bad-func-def -> ["invalid function definition:" :arg1]
    bad-func-arg -> ["function argument" :arg1 "is not valid"]
    bad-func-extern -> ["invalid /extern value:" :arg1]
    no-refine -> [:arg1 "has no refinement called" :arg2]
    bad-refines -> "incompatible or invalid refinements"
    bad-refine -> ["incompatible refinement:" :arg1]
    word-first -> ["path must start with a word:" :arg1]
    empty-path -> "cannot evaluate an empty path value"
    invalid-path -> ["cannot access" :arg2 "in path" :arg1]
    invalid-path-set -> ["unsupported type in" :arg1 "set-path"]
    invalid-path-get -> ["unsupported type in" :arg1 "get-path"]
    bad-path-type -> ["path" :arg1 "is not valid for" :arg2 "type"]
    bad-path-set -> ["cannot set" :arg2 "in path" :arg1]
    bad-field-set -> ["cannot set" :arg1 "field to" :arg2 "datatype"]
    dup-vars -> ["duplicate variable specified:" :arg1]
    past-end -> "out of range or past end"
    missing-arg -> "missing a required argument or refinement"
    out-of-range -> ["value out of range:" :arg1]
    invalid-chars -> "contains invalid characters"
    invalid-compare -> ["cannot compare" :arg1 "with" :arg2]
    wrong-type -> ["datatype assertion failed for:" :arg1]
    invalid-refine-arg -> ["invalid" :arg1 "argument:" :arg2]
    type-limit -> [:arg1 "overflow/underflow"]
    size-limit -> ["maximum limit reached:" :arg1]
    no-return -> "block did not return a value"
    throw-usage -> "invalid use of a thrown error value"
    locked-word -> ["protected word - cannot modify:" :arg1]
    bad-bad -> [:arg1 "error:" :arg2]
    bad-make-arg -> ["cannot MAKE" :arg1 "from:" :arg2]
    bad-to-arg -> ["cannot MAKE/TO" :arg1 "from:" :arg2]
    invalid-spec-field -> ["invalid" :arg1 "field in spec block"]
    missing-spec-field -> [:arg1 "not found in spec block"]
    move-bad -> ["Cannot MOVE elements from" :arg1 "to" :arg2]
    too-long -> "Content too long"
    invalid-char -> ["Invalid char! value:" :arg1]
    parse-rule -> ["PARSE - invalid rule or usage of rule:" :arg1]
    parse-end -> ["PARSE - unexpected end of rule after:" :arg1]
    parse-invalid-ref -> ["PARSE - get-word refers to a different series!" :arg1]
    parse-block -> ["PARSE - input must be of any-block! type:" :arg1]
    parse-unsupported -> {PARSE - matching by datatype not supported for any-string! input}
    parse-infinite -> ["PARSE - infinite recursion at rule: [" :arg1 "]"]
    parse-stack -> "PARSE - stack limit reached"
    parse-keep -> "PARSE - KEEP is used without a wrapping COLLECT"
    parse-into-bad -> {PARSE - COLLECT INTO/AFTER expects a series! argument}
    invalid-draw -> ["invalid Draw dialect input at:" :arg1]
    invalid-data-facet -> ["invalid DATA facet content" :arg1]
    face-type -> ["VIEW - invalid face type:" :arg1]
    not-window -> "VIEW - expected a window root face"
    bad-window -> {VIEW - a window face cannot be nested in another window}
    not-linked -> "VIEW - face not linked to a window"
    not-event-type -> ["VIEW - not a valid event type" :arg1]
    invalid-facet-type -> ["VIEW - invalid rate value:" :arg1]
    vid-invalid-syntax -> ["VID - invalid syntax at:" :arg1]
    react-bad-func -> {REACT - /LINK option requires a function! as argument}
    react-not-enough -> {REACT - reactive functions must accept at least 2 arguments}
    react-no-match -> {REACT - objects block length must match reaction function arg count}
    react-bad-obj -> "REACT - target can only contain object values"
    react-gctx -> ["REACT - word" :arg1 "is not a reactor's field"]
    lib-invalid-arg -> ["LIBRED - invalid argument for" :arg1]
math ( 400 )
    zero-divide -> "attempt to divide by zero"
    overflow -> "math or number overflow"
    positive -> "positive number required"
access ( 500 )
    cannot-open -> ["cannot open:" :arg1]
    invalid-utf8 -> ["invalid UTF-8 encoding:" :arg1]
    no-connect -> ["cannot connect:" :arg1 "reason: timeout"]
user ( 800 )
    message -> [:arg1]
internal ( 900 )
    bad-path -> ["bad path:" arg1]
    not-here -> [arg1 "not supported on your system"]
    no-memory -> "not enough memory"
    wrong-mem -> "failed to release memory"
    stack-overflow -> "stack overflow"
    too-deep -> "block or paren series is too deep to display"
    feature-na -> "feature not available"
    not-done -> "reserved for future use (or not yet implemented)"
    invalid-error -> "error object or fields were not valid"
    routines -> {routines require compilation, from OS shell: `red -c <script.red>`}
    red-system -> {contains Red/System code which requires compilation}
....
== Additional documentation

The following is a list of official documents that complement the information given in this one.

. https://github.com/red/red/blob/master/README.md[README file for the toolchain]
. http://static.red-lang.org/red-system-specs-light.html[Red/System Language Specification]
. https://doc.red-lang.org/en/[Red Programming Language Documentation] notably:
  .. https://doc.red-lang.org/en/map.html[map! datatype]
  .. https://doc.red-lang.org/en/gui.html[GUI System]
  .. https://doc.red-lang.org/en/reactivity.html[Reactive Programming]
  .. https://doc.red-lang.org/en/preprocessor.html[Preprocessor]
. http://www.red-lang.org/2013/11/041-introducing-parse.html[Introducing Parse] (blog article from 2013)
